#!/usr/bin/env python
import urllib, urllib.parse, urllib.request
import tempfile
import sys, os
import re, json
import platform
import subprocess, shutil

def Import(uri,path):    
    #Make temp folder
    temp_folder=tempfile.mkdtemp()

    os.makedirs(path,exist_ok=True)
    
    #Convert urls into a proper format:
    if uri.count('/')==0: #Official Docker libraries
        uri='library/' + uri
        
    if uri.count('/')==1: #The default is docker
        uri='registry-1.docker.io/' + uri
        
    #There's no https, we should fix that so urllib can extract things properly
    if urllib.parse.urlparse(uri).netloc=='':
        uri='https://' + uri
    registry=urllib.parse.urlparse(uri).netloc

    image=urllib.parse.urlparse(uri).path
    
    if image.startswith('/'):
        image=image[1:]
        
    image = image.split(':')
    
    if len(image)==1:
        image.append('latest')
    
    image, tag= image
    #Get registry service and auth service 
    registry_service="registry.docker.io" #By default, use Docker
    auth_service="https://auth.docker.io/token" #By default, use Docker
    try:
        urllib.request.urlopen(f"https://{registry}/v2/")
    except urllib.error.HTTPError as HTTPError:
        if "WWW-Authenticate" in HTTPError.headers:
            authenticate_header=HTTPError.headers["WWW-Authenticate"]
            authenticate_header=authenticate_header.split('"')
            auth_service = authenticate_header[1]
            try:
                registry_service = authenticate_header[3].replace("https://","").replace("http://","")
            except IndexError:
                registry_service = ""
    #Get token
    token=urllib.request.urlopen(f"{auth_service}?service={registry_service}&scope=repository:{image}:pull").read().decode()
    token=json.loads(token)["token"]
    headers={}
    headers['Authorization']=f"Bearer {token}"
    headers["Accept"]="application/vnd.docker.distribution.manifest.list.v2+json"
    
   
    manifest_request=urllib.request.Request(f"https://{registry}/v2/{image}/manifests/{tag}", headers=headers)
    manifest=urllib.request.urlopen(manifest_request).read().decode()
    manifest=json.loads(manifest)
    #Find the architecture 
    architecture=platform.machine()
    #Handle some Linux distros that report aarch64 instead of amr64
    if architecture=='aarch64':
        architecture=['arm64']
        
    #Handle the arm* family
    elif architecture.startswith('arm'):
        
        #Handle armv6, armv7l, etc.
        if 'v' in architecture:
            architecture=architecture.split('v')
            architecture[1]='v'+architecture[1]
        else:
            architecture=[architecture]
    else:
        architecture=[architecture]
    
    #Get right manifest for architecture
    if 'manifests' in manifest: #Multi-arch manifest, so you have to choose the right one
        manifest_list=manifest['manifests']
        
        for manifest in manifest_list:
            if manifest['platform']['architecture']==architecture[0]:
                #Deal with armv* family
                if len(architecture)==2:
                    if manifest['platform']['variant']==architecture[1]:
                        digest=manifest['digest']
                        break
                else:
                    digest=manifest['digest']
                    break
        manifest_request=urllib.request.Request(f"https://{registry}/v2/{image}/manifests/{digest}", headers=headers)
        manifest=urllib.request.urlopen(manifest_request).read().decode()
        manifest=json.loads(manifest)
        #tag=digest
        
#    print(dict(headers,Accept="application/vnd.docker.container.image.v1+json"))
#    config_request=urllib.request.Request(f"https://{registry}/v2/{image}/manifests/{tag}", headers=dict(headers,Accept="application/vnd.docker.container.image.v1+json"))
#    config=urllib.request.urlopen(config_request).read().decode()
#    print(json.loads(config))
#    exit()

    #Get information about layers
    layers=manifest["layers"] if "layers" in manifest else manifest["fsLayers"] #Support v1
    layers=[_["digest"] if "digest" in _ else _["blobSum"] for _ in layers] #Support v1
    
    
    #Special code for urlretrieve
    opener = urllib.request.build_opener()
    opener.addheaders = [('Authorization', f"Bearer {token}")]
    urllib.request.install_opener(opener)
    #Download layers
    for i in range(len(layers)):
        urllib.request.urlretrieve(f"https://{registry}/v2/{image}/blobs/{layers[i]}", f"{temp_folder}/layer_{i}.tar.gz")
        
        #Extract layer to container and remove it
        subprocess.run(["tar","-xf",f"{temp_folder}/layer_{i}.tar.gz","-C",path])
        os.remove(f"{temp_folder}/layer_{i}.tar.gz")
    
    shutil.rmtree(temp_folder)

#Convert Dockerfile to Containerfile
def Convert():
    IN=NAME[0]
    OUT=NAME[1]
    
    #Convert a line of a Dockerfile into a Container file
    def docker_to_container(line):
        COMMAND=line.split(' ')[0]
        line=line.split(' ')[1:]
        #Remove flags from line
        for i in range(len(line)):
            if not line[i].startswith("--"):
                line=line[i:]
                break
        
        line=list(filter(None,line))
        result=[]
        if COMMAND=='FROM':
            result=["Base",f"{split_by_char(line[0])[0]}"]
        elif COMMAND=='RUN':
            result=["Run",f"{' '.join(line)}"]
        elif COMMAND=='WORKDIR':
            result=["Workdir",f"{line[0]}"]
        elif COMMAND=='COPY':
            result=["Copy",f"{line[0]}",f"{line[1]}"]
        elif COMMAND=='ENV':
            result=["Env",f"{' '.join(line)}"]
        else:
            result=['','']
        
        #Escape all strings because of Python syntax
        if ''.join(result):
            result=['"'+result[_].replace("'", r'\'').replace('"', r'\"')+'"' if _!=0 else result[_] for _ in range(len(result))]
        
        return result[0]+f"({', '.join(result[1:])})"
        
    #Move all bash line breaks to one line
    with open(IN,'r') as f:
        Dockerfile=f.read().replace("\\\n"," ")
    
    with open(OUT,'w') as f:    
        for line in Dockerfile.splitlines():
            line=line.strip()
            if not line.startswith('#') and line:
                result=docker_to_container(line)
                if result!="()":
                    f.write(result+"\n")

Import(sys.argv[1],"")
