#!/usr/bin/env python
import urllib, urllib.parse, urllib.request
import tempfile
import sys, os
import re, json
import platform
import subprocess, shutil
# < include '../utils/utils.py' >
import utils
import collections, contextlib
def Import(uri,path):    
    #Make temp folder
    temp_folder=tempfile.mkdtemp()

    os.makedirs(path,exist_ok=True)
    
    #Convert urls into a proper format:
    if uri.count('/')==0: #Official Docker libraries
        uri='library/' + uri
        
    if uri.count('/')==1: #The default is docker
        uri='registry-1.docker.io/' + uri
        
    #There's no https, we should fix that so urllib can extract things properly
    if urllib.parse.urlparse(uri).netloc=='':
        uri='https://' + uri
    registry=urllib.parse.urlparse(uri).netloc

    image=urllib.parse.urlparse(uri).path
    
    if image.startswith('/'):
        image=image[1:]
        
    image = image.split(':')
    
    if len(image)==1:
        image.append('latest')
    
    image, tag= image
    #Get registry service and auth service 
    registry_service="registry.docker.io" #By default, use Docker
    auth_service="https://auth.docker.io/token" #By default, use Docker
    try:
        urllib.request.urlopen(f"https://{registry}/v2/")
    except urllib.error.HTTPError as HTTPError:
        if "WWW-Authenticate" in HTTPError.headers:
            authenticate_header=HTTPError.headers["WWW-Authenticate"]
            authenticate_header=authenticate_header.split('"')
            auth_service = authenticate_header[1]
            try:
                registry_service = authenticate_header[3].replace("https://","").replace("http://","")
            except IndexError:
                registry_service = ""
    #Get token
    token=urllib.request.urlopen(f"{auth_service}?service={registry_service}&scope=repository:{image}:pull").read().decode()
    token=json.loads(token)["token"]
    headers={}
    headers['Authorization']=f"Bearer {token}"
    headers["Accept"]="application/vnd.docker.distribution.manifest.list.v2+json"
    
   
    manifest_request=urllib.request.Request(f"https://{registry}/v2/{image}/manifests/{tag}", headers=headers)
    manifest=urllib.request.urlopen(manifest_request).read().decode()
    manifest=json.loads(manifest)
    #Find the architecture 
    architecture=platform.machine()
    #Handle some Linux distros that report aarch64 instead of amr64
    if architecture=='aarch64':
        architecture=['arm64']
        
    #Handle the arm* family
    elif architecture.startswith('arm'):
        
        #Handle armv6, armv7l, etc.
        if 'v' in architecture:
            architecture=architecture.split('v')
            architecture[1]='v'+architecture[1]
        else:
            architecture=[architecture]
    else:
        architecture=[architecture]
    
    #Get right manifest for architecture
    if 'manifests' in manifest: #Multi-arch manifest, so you have to choose the right one
        manifest_list=manifest['manifests']
        
        for manifest in manifest_list:
            if manifest['platform']['architecture']==architecture[0]:
                #Deal with armv* family
                if len(architecture)==2:
                    if manifest['platform']['variant']==architecture[1]:
                        digest=manifest['digest']
                        break
                else:
                    digest=manifest['digest']
                    break
        manifest_request=urllib.request.Request(f"https://{registry}/v2/{image}/manifests/{digest}", headers=headers)
        manifest=urllib.request.urlopen(manifest_request).read().decode()
        manifest=json.loads(manifest)
        #tag=digest
        
#    print(dict(headers,Accept="application/vnd.docker.container.image.v1+json"))
#    config_request=urllib.request.Request(f"https://{registry}/v2/{image}/manifests/{tag}", headers=dict(headers,Accept="application/vnd.docker.container.image.v1+json"))
#    config=urllib.request.urlopen(config_request).read().decode()
#    print(json.loads(config))
#    exit()

    #Get information about layers
    layers=manifest["layers"] if "layers" in manifest else manifest["fsLayers"] #Support v1
    layers=[_["digest"] if "digest" in _ else _["blobSum"] for _ in layers] #Support v1
    
    
    #Special code for urlretrieve
    opener = urllib.request.build_opener()
    opener.addheaders = [('Authorization', f"Bearer {token}")]
    urllib.request.install_opener(opener)
    #Download layers
    for i in range(len(layers)):
        urllib.request.urlretrieve(f"https://{registry}/v2/{image}/blobs/{layers[i]}", f"{temp_folder}/layer_{i}.tar.gz")
        
        #Extract layer to container and remove it
        subprocess.run(["tar","-xf",f"{temp_folder}/layer_{i}.tar.gz","-C",path])
        os.remove(f"{temp_folder}/layer_{i}.tar.gz")
    
    shutil.rmtree(temp_folder)

#Convert Dockerfile to Containerfile
def Convert(IN,OUT):
    
    @contextlib.contextmanager
    def smart_open(filename=None):
        if filename and filename != '-':
            fh = open(filename, 'w')
        else:
            fh = sys.stdout
    
        try:
            yield fh
        finally:
            if fh is not sys.stdout:
                fh.close()
                
    stage="" #Stage name
    stages=[]
    def docker_to_container(line): #Convert a line of a Dockerfile into a Container file
        nonlocal stage
        nonlocal stages
        f_strings=[] #Which elements of line should be an f-string
        line=utils.split_string_by_char(line," ") #Split string for better parsing
        
        COMMAND=line[0].title() #Get first command
        line=line[1:]
        
        FLAGS={}
        for i in range(len(line)):
            if not line[i].startswith("--"): #If true, then it's the start of the actual command and can be kept
                line=line[i:]
                break
            
            flag=line[i].split('=',1) #Split line by '='
            if len(flag)==1:
                flag.append('') #Pad out the flag array
            flag[0]=flag[0][2:] #Remove the '--'
            FLAGS[flag[0]]=flag[1]
        
        line=list(filter(None,line))
    
        if COMMAND=='From':
            COMMAND="Base"
            if "AS" in line: # Multi-stage build
                stage=line[line.index("AS")+1]
                base=line[line.index("AS")-1]
                stages.append(stage)
            else:
                stage=""
                base=line[-1]
            if ':' in base:
                base="'"+base+"'" #Escape base
            
            if stage!="":
                yield f"{stage}=Container('{stage}', ['temp'])"
                yield f"{stage}.Init()"
                yield f"""{stage}.Base("{base}")"""
                yield f"{stage}.Start()"
                return #Nothing else to do
            else:
                line[-1]=base
        elif COMMAND=="Arg": #Not supported
            return "()"
        elif COMMAND=="Run":
            line=[' '.join(line)]
        elif COMMAND=="Expose":
            COMMAND="Port"
            line.append(line[0]) #Port needs two arguments
        elif COMMAND=="Copy":
            if "from" in FLAGS:
                if FLAGS["from"] in stages:
                    line[0]="{{{}.name}}:".format(FLAGS["from"])+line[0].replace("{","{{").replace("}","}}")
                    f_strings.append(0)
        #If there is a stage, append commands with the name
        if stage!="":
            COMMAND=stage+"."+COMMAND
                    
        #Escape all strings
        line=['"""'+line[_].replace("'", r'\'').replace('"', r'\"')+'"""' for _ in range(len(line))]
        for _ in f_strings:
            line[_]='f'+line[_]
        result=', '.join(line)
        yield COMMAND+f"({result})"
        
    #Move all shell line breaks to one line
    with open(IN,'r') as f:
        Dockerfile=f.read().replace("\\\n"," ")
    
    with smart_open(OUT) as f:
        for line in Dockerfile.splitlines():
            line=line.strip()
            line=' '.join(line.split()) #Remove extra spacing
            if not line.startswith('#') and line:
                for result in docker_to_container(line):
                    if result!="()":
                        f.write(result+"\n") 
        for stage in stages:
            f.write(f"{stage}.Delete()\n")
    
    

Convert(sys.argv[1],"-")
