#!/usr/bin/env python
import subprocess
import re
import sys
import os
import signal
import typing
import tempfile
import shutil
import functools
import urllib.request
import json
import tarfile
from pprint import pprint
import platform

ROOT=os.path.expanduser("~/Containers")

arguments=sys.argv[1:]
FUNCTION=arguments[0]
arguments=arguments[1:]
NAME=[]
flags=arguments
TEMP=tempfile.gettempdir()
PATTERN = re.compile(r'''((?:[^\:"']|"[^"]*"|'[^']*')+)''')



#Helper functions
def List(Names):
    names=Names
    AllContainers=os.listdir(f"{ROOT}")
    
    if "--started" in flags:
        names+=[_ for _ in AllContainers if "Started" in Container(_).Status() ]
    if "--stopped" in flags:
        names+=[_ for _ in AllContainers if "Stopped" in Container(_).Status() ]
    if "--all" in flags:
        names+=AllContainers
    
    return names
    
def flatten(items):
    """Yield items from any nested iterable; see Reference."""
    for x in items:
        if isinstance(x, typing.Iterable) and not isinstance(x, (str, bytes)):
            for sub_x in flatten(x):
                yield sub_x
        else:
            yield x

def print_result(result):
    for element in result:
        if element is None:
            print(end='')
        else:
            print(element)

def Shell(command,block=True):
    if block:
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True,universal_newlines=True)
        return process.communicate()[0]
    else:
        process = subprocess.Popen(command, shell=True,stderr=subprocess.STDOUT,universal_newlines=True)




class ContainerDoesNotExist(Exception):
    pass
    
class Container:
    def __init__(self,_container,_flags=None,_unionopts=None):
        self.container=_container
        if _flags is None:
            self.flags=flags
        else:
            self.flags=_flags
            
        self.base="void"
        
        if _unionopts is None:
            self.unionopts="diff=RW"
        else:
            self.unionopts=_unionopts
        
        #Whether we mounted dev, proc, etc.
        self.mounted_special=False
        
        if FUNCTION not in ["init","import"]:
            if not os.path.isdir(f"{ROOT}/{self.container}"):
                 raise ContainerDoesNotExist()
                 return
            os.chdir(f"{ROOT}/{self.container}")

    def Run(self,command="",block=False):
        self.Base(self.base)
        #Only mount if this is the first Run called, where the base hasn't been added to unionopts
        if not self.unionopts.endswith(f":{ROOT}/{self.base}/diff=RO"):
            self.unionopts+=f":{ROOT}/{self.base}/diff=RO"
            
            #Prevent merged from being mounted multiple times
            if not os.path.ismount("merged"):
                Shell(f"unionfs -o allow_other,cow,hide_meta_files {self.unionopts} merged")
    
        #Mount dev,proc, etc. over the unionfs to deal with mmap bugs (fuse may be patched to deal with this natively, but for now, this is what is needed)
        if not self.mounted_special:
            for dir in ["dev","proc","sys","run"]:
                if not os.path.ismount(f"merged/{dir}"):
                    #Use bind mounts for special mounts, as bindfs has too many quirks (and I'm using sudo regardless)
                    #Shell(f"sudo bindfs -o direct_io,allow_other,dev /{dir} merged/{dir}")
                    Shell(f"sudo mount --rbind /{dir} merged/{dir}")
            self.mounted_special=True

        Shell(f""" PATH={PATH} sudo nohup chroot --userspec=$(id -u):$(id -g) merged bash -c "{command}" > {TEMP}/container_{self.container}.log 2>&1""",block=block)
    
    def GetProc(self):
        
        if os.path.isdir("merged"):
           return list(map(int,Shell("lsof -Fp -- merged | cut -c 2-").splitlines()))
        else:
            return []
    
    def Mount(self,IN,OUT):
        arrIN = [_ for _ in list(PATTERN.split(IN)) if _ not in ['', ':']]
        
        os.makedirs(f"diff{OUT}",exist_ok=True)
        if not os.path.ismount(f"diff{OUT}"):
            if arrIN[0]=="root":
               Shell(f"bindfs {arrIN[1]} diff{OUT}")
            elif len(arrIN)==1:
                Shell(f"bindfs {arrIN[0]} diff{OUT}")
            else:
               Shell(f"bindfs {ROOT}/{arrIN[0]}/diff{arrIN[1]} diff{OUT}")

    def Base(self,base):
        self.base=base

    def Layer(self,layer,mode="RO"):
        self.unionopts+=f":{ROOT}/{layer}/diff={mode}"
            
    def Start(self):
        
        self.Base(self.base)
        if self.Status()=="Started":
            return f"Container {self.container} is already started"
        
        with open("container-compose.py") as f:
            code = compile(f.read(), 'container-compose.py', 'exec')
            exec(code,globals(),locals())
            
        #Don't have to put Run() in container-compose.py just to start it
        Run()
        if "--only-chroot" in self.flags:
            return [ self.Chroot(), self.Stop()]
        elif "--and-chroot" in self.flags:
            return [self.Chroot()]
        
    def Build(self):
        
        self.Stop()
        
        #Redefine Run for build=True
        Run=functools.partial(self.Run,block=True)
        with open("Containerfile") as f:
         code = compile(f.read(), 'Containerfile', 'exec')
         exec(code,globals(),locals())
        self.Stop()
       
    def Stop(self):
        if self.Status()=="Stopped":
            if self.container!=self.base:
                #return f"Container {self.container} is already stopped"
                pass
        for pid in self.GetProc():
            os.kill(pid,signal.SIGKILL)
        
        #Unmount dev,proc, etc. if directory exists
        if os.path.isdir("merged"):
            for dir in os.listdir("merged"):
                if os.path.ismount(f"merged/{dir}"):
                    #Shell(f"sudo umount -l merged/{dir}")
                    Shell(f"sudo mount --make-rslave merged/{dir}")
                    Shell(f"sudo umount -R -l merged/{dir}")

        for dir in Shell(f"mount | awk '$0=$3' | grep {ROOT}/{self.container}/diff").splitlines():
             Shell(f"umount -l {dir}")
        try:
           os.remove(f"{TEMP}/container_{self.container}.log")
        except FileNotFoundError:
            pass
        
        Shell("umount -l merged")

    def Restart(self):
        return [self.Stop(),self.Start()]
    
    def Chroot(self):
        if self.flags==[] and ("Stopped" in self.Status()):
            return [Container(self.container,self.flags+['--only-chroot'],self.unionopts).Start()]
        os.system(f" PATH={PATH} sudo chroot --userspec=$(id -u):$(id -g) {ROOT}/{self.container}/merged bash")
    
    
    def List(self):
        return self.container

    def Init(self):
       
        os.makedirs(f"{ROOT}/{self.container}",exist_ok=True)
        os.chdir(f"{ROOT}/{self.container}")
        os.makedirs("diff",exist_ok=True)
        os.makedirs("merged",exist_ok=True)
        with open(f"container-compose.py",'a'):
            pass
        
        if '--build' in self.flags:
            with open(f"Containerfile",'a'):
                pass
        
        if '--no-edit' not in self.flags:
            self.Edit()
        
        if '--and-chroot' in self.flags:
            return [Container(self.container,self.flags+['--only-chroot'],self.unionopts).Start()]

    def Edit(self):
        if '--build' in self.flags:
            os.system(f"$EDITOR {ROOT}/{self.container}/Containerfile")
        else:
            os.system(f"$EDITOR {ROOT}/{self.container}/container-compose.py")

    def Status(self):
        if os.path.isfile(f"{TEMP}/container_{self.container}.log"):
            return "Started"
        else:
            return "Stopped"

    def Log(self):
        os.system(f"less +G {TEMP}/container_{self.container}.log")
    
    def Clean(self):
        self.Stop()
        os.system(f"sudo rm -rf diff/*")
    
    def Delete(self):
        self.Stop()
        os.system(f"sudo rm -rf {ROOT}/{self.container}")

#Special functions
def Import():
    
    #Make temp folder
    temp_folder=tempfile.mkdtemp()
    
    
    image=arguments[0]
    container=arguments[1]
    
    image = [_ for _ in list(PATTERN.split(image)) if _ not in ['', ':']]
    
    #Support Docker official images
    if '/' not in image[0]:
        image[0]='library/'+image[0]
        
    if len(image)==1:
        image.append('latest')
        
    #Get token
    token=urllib.request.urlopen(f"https://auth.docker.io/token?service=registry.docker.io&scope=repository:{image[0]}:pull").read().decode()
    
    token=json.loads(token)["token"]
    
    
    #Get right architecture
    manifest_list=urllib.request.Request(f"https://index.docker.io/v2/{image[0]}/manifests/{image[1]}", headers={'Authorization':f"Bearer {token}","Accept":"application/vnd.docker.distribution.manifest.list.v2+json"})
    
    manifest_list=urllib.request.urlopen(manifest_list).read().decode()
    
    architecture=platform.machine()
    
    #Handle some Linux distros that report aarch64 instead of amr64
    if architecture=='aarch64':
        architecture=['arm64']
        
    #Handle the arm* family
    elif architecture.startswith('arm'):
        
        #Handle armv6, armv7l, etc.
        if 'v' in architecture:
            architecture=architecture.split('v')
            architecture[1]='v'+architecture[1]
        else:
            architecture=[architecture]
    else:
        architecture=[architecture]
        
    manifest_list=json.loads(manifest_list)['manifests']
    
    for manifest in manifest_list:
        if manifest['platform']['architecture']==architecture[0]:
            #Deal with armv* family
            if len(architecture)==2:
                if manifest['platform']['variant']==architecture[1]:
                    digest=manifest['digest']
                    break
            else:
                digest=manifest['digest']
                break

    #Get information about layers
    
    layers=urllib.request.Request(f"https://index.docker.io/v2/{image[0]}/manifests/{digest}", headers={'Authorization':f"Bearer {token}","Accept":"application/vnd.docker.distribution.manifest.v2+json"})
    
    
    layers=urllib.request.urlopen(layers).read().decode()
    
    #config=json.loads(layers)['config']
    #config=urllib.request.Request(f"https://index.docker.io/v2/{image[0]}/manifests/{config['digest']}", headers={'Authorization':f"Bearer {token}","Accept":config['mediaType']})
    #config=urllib.request.urlopen(config).read().decode()
    
    layers=json.loads(layers)["layers"]
    
    layers=[_["digest"] for _ in layers]
    
    
    #Special code for urlretrieve
    opener = urllib.request.build_opener()
    opener.addheaders = [('Authorization', f"Bearer {token}")]
    urllib.request.install_opener(opener)
    
    #Download layers
    for i in range(len(layers)):
        urllib.request.urlretrieve(f"https://index.docker.io/v2/{image[0]}/blobs/{layers[i]}", f"{temp_folder}/layer_{i}.tar.gz")
    
    #Initialize container
    Container(container,_flags=flags+['--no-edit']).Init()
    
    #Extract to container
    for tar in os.listdir(temp_folder):
        tar = tarfile.open(f"{temp_folder}/{tar}")
        tar.extractall(f"{ROOT}/{container}/diff")
        tar.close()
    
    shutil.rmtree(temp_folder)
#If FUNCTION is one of the "special functions", do that
if FUNCTION in ["import"]:
    globals()[FUNCTION.title()]()
    exit()

#Else, it's one of the standard functions:
    
#Flags go before the actual container names
for i in range(len(arguments)):
    if not arguments[i].startswith("--"):
        flags=arguments[:i]
        NAME=arguments[i:]
        break

#If there's only a function name
if flags==[] and NAME==[]:
    flags+=["--all"]

NAME=List(NAME)
for name in NAME:
    PATH="$PATH:/bin:/usr/sbin:/sbin:/usr/bin"
    
    BASE="void"
    UNIONOPTS="diff=RW"
    
    try:
        container=Container(name,flags,UNIONOPTS)
    except ContainerDoesNotExist:
        print(f"Container {name} does not exist")
        continue
    Run=container.Run
    Layer=container.Layer
    Mount=container.Mount
    Base=container.Base
    
    result=list(flatten([getattr(container,FUNCTION.title())()]))
    print_result(result)
        

    
