#!/usr/bin/env python
import subprocess
import re
import sys
import os
import threading
import time
import ast
#import pwd, grp
import json
import hashlib
import signal
import shutil
import random
import types
import getpass



import types
import sys
import base64
utils_module=types.ModuleType("utils")
#setattr(utils_module,"__file__",__file__)
exec(base64.b64decode(b'aW1wb3J0IHN1YnByb2Nlc3MKaW1wb3J0IHJlCmltcG9ydCB0ZW1wZmlsZQppbXBvcnQgb3MKaW1wb3J0IHBhdGhsaWIKaW1wb3J0IHNpZ25hbCAKaW1wb3J0IHRpbWUKaW1wb3J0IHN5cwppbXBvcnQgdHlwaW5nCmltcG9ydCBzaHV0aWwKaW1wb3J0IHRocmVhZGluZwppbXBvcnQgY29udGV4dGxpYgoKZm9yIHZhciBpbiBbIlJPT1QiLCJHTE9CQUxTIiwiQ0xBU1MiXToKICAgIGdsb2JhbHMoKVt2YXJdPU5vbmUKICAgIApkZWYgZ2V0X3RlbXBkaXIoKToKICAgIGlmIG9zLnVuYW1lKCkuc3lzbmFtZT09IkRhcndpbiI6CiAgICAgICAgcmV0dXJuICIvdG1wIgogICAgZWxzZToKICAgICAgICByZXR1cm4gdGVtcGZpbGUuZ2V0dGVtcGRpcigpCiAgICAKVEVNUERJUj1nZXRfdGVtcGRpcigpCgoKY2xhc3MgRG9lc05vdEV4aXN0KEV4Y2VwdGlvbik6CiAgICBwYXNzCgpkZWYgZ2V0X3ZhbHVlKHZhcmlhYmxlLGRlZmF1bHQpOgoJaWYgbm90IHZhcmlhYmxlOgoJCXJldHVybiBkZWZhdWx0CgllbHNlOgoJCXJldHVybiB2YXJpYWJsZQoKZGVmIGdldF9yb290X2RpcmVjdG9yeShyb290X3ZhcmlhYmxlPU5vbmUsZGVmYXVsdF92YWx1ZT1Ob25lKToKICAgIHJvb3RfdmFyaWFibGU9Z2V0X3ZhbHVlKHJvb3RfdmFyaWFibGUsZiJ7Q0xBU1MuX19uYW1lX18udXBwZXIoKX1fUk9PVCIpCiAgICBkZWZhdWx0X3ZhbHVlPWdldF92YWx1ZShkZWZhdWx0X3ZhbHVlLGYie29zLmVudmlyb25bJ0hPTUUnXX0ve0NMQVNTLl9fbmFtZV9fLnRpdGxlKCl9cyIpCiAgICByZXR1cm4gb3MucGF0aC5leHBhbmR1c2VyKG9zLmdldGVudihyb290X3ZhcmlhYmxlLGRlZmF1bHRfdmFsdWUpKQoKIAogICAgCiNST09UPU5vbmUKI05BTUVTPU5vbmUKI0ZMQUdTPU5vbmUKI0ZVTkNUSU9OPU5vbmUKI1RFTVBESVI9Tm9uZQoKZGVmIGxpc3RfaXRlbXNfaW5fcm9vdChuYW1lcyxmbGFncyk6CiAgICBBbGw9W18gZm9yIF8gaW4gc29ydGVkKG9zLmxpc3RkaXIoUk9PVCkpIGlmIG5vdCBfLnN0YXJ0c3dpdGgoJy4nKSBdCiAgICAKICAgIGZvciBmbGFnIGluIFsic3RhcnRlZCIsInN0b3BwZWQiLCJlbmFibGVkIiwiZGlzYWJsZWQiXToKICAgICAgICBpZiAiLS0iK2ZsYWcgaW4gZmxhZ3M6CiAgICAgICAgICAgIG5hbWVzKz1bXyBmb3IgXyBpbiBBbGwgaWYgZmxhZy50aXRsZSgpIGluIENMQVNTKF8pLlN0YXR1cygpIF0KICAgICAgICAgICAgZmxhZ3MucmVtb3ZlKCItLSIrZmxhZykKCiAgICBpZiAiLS1hbGwiIGluIGZsYWdzOgogICAgICAgIG5hbWVzKz1BbGwKICAgICAgICBmbGFncy5yZW1vdmUoIi0tYWxsIikKICAgIGlmIG5hbWVzPT1bXToKICAgICAgICBwcmludChmIk5vIHtDTEFTUy5fX25hbWVfXy5sb3dlcigpfXMgc3BlY2lmaWVkISIpCiAgICAgICAgZXhpdCgpCiAgICByZXR1cm4gbmFtZXMKCmRlZiBmbGF0dGVuX2xpc3QoaXRlbXMpOgogICAgIiIiWWllbGQgaXRlbXMgZnJvbSBhbnkgbmVzdGVkIGl0ZXJhYmxlLiIiIgogICAgZm9yIHggaW4gaXRlbXM6CiAgICAgICAgaWYgaXNpbnN0YW5jZSh4LCB0eXBpbmcuSXRlcmFibGUpIGFuZCBub3QgaXNpbnN0YW5jZSh4LCAoc3RyLCBieXRlcykpOgogICAgICAgICAgICBmb3Igc3ViX3ggaW4gZmxhdHRlbl9saXN0KHgpOgogICAgICAgICAgICAgICAgeWllbGQgc3ViX3gKICAgICAgICBlbHNlOgogICAgICAgICAgICB5aWVsZCB4CgpkZWYgcHJpbnRfbGlzdChsKToKICAgIGZvciBlbGVtZW50IGluIGw6CiAgICAgICAgaWYgZWxlbWVudCBpcyBOb25lOgogICAgICAgICAgICBwcmludChlbmQ9JycpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcHJpbnQoZWxlbWVudCkKCmRlZiBzcGxpdF9zdHJpbmdfYnlfY2hhcihzdHJpbmcsY2hhcj0nOicpOgogICAgUEFUVEVSTiA9IHJlLmNvbXBpbGUocmYnJycoKD86W15ce2NoYXJ9IiddfCJbXiJdKiJ8J1teJ10qJykrKScnJykKICAgIHJldHVybiBbXyBmb3IgXyBpbiBsaXN0KFBBVFRFUk4uc3BsaXQoc3RyaW5nKSkgaWYgXyBub3QgaW4gWycnLCBjaGFyXV0KCgpkZWYgc2hlbGxfY29tbWFuZChjb21tYW5kLHN0ZG91dD1zdWJwcm9jZXNzLlBJUEUsc3RkZXJyPXN1YnByb2Nlc3MuU1RET1VULGFyYml0cmFyeT1GYWxzZSxibG9jaz1UcnVlLGVudj1Ob25lKToKICAgIHByb2Nlc3MgPSBzdWJwcm9jZXNzLlBvcGVuKGNvbW1hbmQsIHN0ZG91dD1zdGRvdXQsIHN0ZGVycj1zdGRlcnIsdW5pdmVyc2FsX25ld2xpbmVzPVRydWUsc2hlbGw9YXJiaXRyYXJ5LGVudj1lbnYpCiAgICBpZiBibG9jazoKICAgICAgICByZXR1cm4gcHJvY2Vzcy5jb21tdW5pY2F0ZSgpWzBdCgpkZWYgd2FpdF91bnRpbF9waWRfZXhpdHMocGlkKToKICAgIAogICAgZGVmIHBpZF9leGlzdHMocGlkKTogICAKICAgICAgICAiIiIgQ2hlY2sgRm9yIHRoZSBleGlzdGVuY2Ugb2YgYSB1bml4IHBpZC4gIiIiCiAgICAgICAgdHJ5OgogICAgICAgICAgICBvcy5raWxsKHBpZCwgMCkKICAgICAgICBleGNlcHQgT1NFcnJvcjoKICAgICAgICAgICAgcmV0dXJuIEZhbHNlCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmV0dXJuIFRydWUKICAgICAgICAgICAgCiAgICB3aGlsZSBwaWRfZXhpc3RzKHBpZCk6CiAgICAgICAgdGltZS5zbGVlcCgwLjI1KQogICAgICAgIApkZWYga2lsbF9wcm9jZXNzX2dyYWNlZnVsbHkocGlkKToKICAgIAogICAgdHJ5OgogICAgICAgIG9zLmtpbGwocGlkLHNpZ25hbC5TSUdURVJNKQogICAgICAgIHRyeToKICAgICAgICAgICAgb3Mud2FpdHBpZChwaWQsMCkKICAgICAgICBleGNlcHQgQ2hpbGRQcm9jZXNzRXJyb3I6ICNOb3QgYSBjaGlsZCBwcm9jZXNzIHNvIG1vdmUgb24KICAgICAgICAgICAgcGFzcwogICAgICAgIHdhaXRfdW50aWxfcGlkX2V4aXRzKHBpZCkKICAgIGV4Y2VwdCBQcm9jZXNzTG9va3VwRXJyb3I6CiAgICAgICAgcGFzcwogICAgCmRlZiBleHRyYWN0X2FyZ3VtZW50cygpOgogICAgYXJndW1lbnRzPXN5cy5hcmd2WzE6XQogICAgdHJ5OgogICAgICAgIEZVTkNUSU9OPWFyZ3VtZW50c1swXQogICAgZXhjZXB0IEluZGV4RXJyb3I6CiAgICAgICAgcHJpbnQoIk5vIGZ1bmN0aW9uIHNwZWNpZmllZCEiKQogICAgICAgIGV4aXQoKQogICAgYXJndW1lbnRzPWFyZ3VtZW50c1sxOl0KICAgIAogICAgTkFNRVM9W10KICAgIEZMQUdTPWFyZ3VtZW50cwogICAgZm9yIGkgaW4gcmFuZ2UobGVuKGFyZ3VtZW50cykpOgogICAgICAgIGlmIG5vdCBhcmd1bWVudHNbaV0uc3RhcnRzd2l0aCgiLS0iKToKICAgICAgICAgICAgRkxBR1M9YXJndW1lbnRzWzppXQogICAgICAgICAgICBOQU1FUz1hcmd1bWVudHNbaTpdCiAgICAgICAgICAgIGJyZWFrCiAgICByZXR1cm4gKE5BTUVTLEZMQUdTLEZVTkNUSU9OKQoKZGVmIGFkZF9lbnZpcm9ubWVudF92YXJpYWJsZV90b19zdHJpbmcoc3RyaW5nLGVudl92YXIpOgogICAgcmV0dXJuIHN0cmluZytmIjsgZXhwb3J0IHtlbnZfdmFyfSIKCmRlZiB3YWl0KGRlbGF5PU5vbmUpOgogICAgdGhyZWFkaW5nLkV2ZW50KCkud2FpdCh0aW1lb3V0PWRlbGF5KQoKZGVmIGV4ZWN1dGVfY2xhc3NfbWV0aG9kKGNsYXNzX2luc3RhbmNlLGZ1bmN0aW9uKToKICAgIGlmIG5vdCBjYWxsYWJsZShnZXRhdHRyKGNsYXNzX2luc3RhbmNlLCBmdW5jdGlvbi50aXRsZSgpLE5vbmUpKToKICAgICAgICAgICAgcHJpbnQoZiJDb21tYW5kIHtmdW5jdGlvbn0gZG9lc24ndCBleGlzdCEiKQogICAgICAgICAgICBleGl0KCkKICAgIGVsc2U6CiAgICAgICAgcmV0dXJuIGxpc3QoZmxhdHRlbl9saXN0KFtnZXRhdHRyKGNsYXNzX2luc3RhbmNlLGZ1bmN0aW9uLnRpdGxlKCkpKCldKSkKCmRlZiBjaGVja19pZl9lbGVtZW50X2FueV9pc19pbl9saXN0KGVsZW1lbnRzLF9saXN0KToKICAgIHJldHVybiBhbnkoXyBpbiBfbGlzdCBmb3IgXyBpbiBlbGVtZW50cykKICAgIApkZWYgZXhwb3J0X21ldGhvZHNfZnJvbV9zZWxmKHNlbGYpOgogICAgbWV0aG9kcz17fQogICAgZm9yIGZ1bmMgaW4gW2Z1bmMgZm9yIGZ1bmMgaW4gZGlyKHNlbGYpIGlmIGNhbGxhYmxlKGdldGF0dHIoc2VsZiwgZnVuYykpIGFuZCBub3QgZnVuYy5zdGFydHN3aXRoKCdfXycpXToKICAgICAgICBtZXRob2RzW2Z1bmNdPWdldGF0dHIoc2VsZixmdW5jKQogICAgCiAgICByZXR1cm4gbWV0aG9kcwpkZWYgd3JhcF9hbGxfbWV0aG9kc19pbl9jbGFzc193aXRoX2NoZGlyX2NvbnRleHRtYW5hZ2VyKHNlbGYscGF0aCk6CiAgICBAY29udGV4dGxpYi5jb250ZXh0bWFuYWdlcgogICAgZGVmIHNldF9kaXJlY3RvcnkocGF0aCk6CiAgICAgICAgIiIiU2V0cyB0aGUgY3dkIHdpdGhpbiB0aGUgY29udGV4dAogICAgCiAgICAgICAgQXJnczoKICAgICAgICAgICAgcGF0aCAoUGF0aCk6IFRoZSBwYXRoIHRvIHRoZSBjd2QKICAgIAogICAgICAgIFlpZWxkczoKICAgICAgICAgICAgTm9uZQogICAgICAgICIiIgogICAgCiAgICAgICAgb3JpZ2luID0gb3MucGF0aC5hYnNwYXRoKG9zLmdldGN3ZCgpKQogICAgICAgIHRyeToKICAgICAgICAgICAgb3MuY2hkaXIocGF0aCkKICAgICAgICAgICAgeWllbGQKICAgICAgICBmaW5hbGx5OgogICAgICAgICAgICAgICAgb3MuY2hkaXIob3JpZ2luKQogICAgCiAgICBkZWYgd3JhcHBlcihmdW5jKToKICAgICAgICBkZWYgbmV3X2Z1bmMoKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAgICAgd2l0aCBzZXRfZGlyZWN0b3J5KHBhdGgpOgogICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMoKmFyZ3MsICoqa3dhcmdzKQogICAgICAgIHJldHVybiBuZXdfZnVuYwogICAgICAgICAgICAKICAgIGZvciBmdW5jIGluIFtmdW5jIGZvciBmdW5jIGluIGRpcihzZWxmKSBpZiBjYWxsYWJsZShnZXRhdHRyKHNlbGYsIGZ1bmMpKSBhbmQgbm90IGZ1bmMuc3RhcnRzd2l0aCgnX18nKV06CiAgICAgICAgc2V0YXR0cihzZWxmLGZ1bmMsd3JhcHBlcihnZXRhdHRyKHNlbGYsZnVuYykpKQpjbGFzcyBDbGFzczoKICAgIGRlZiBfX2luaXRfXyhzZWxmLGNsYXNzX3NlbGYpOgogICAgICAgIHNlbGYuc2VsZj1jbGFzc19zZWxmCiAgICAgICAgc2VsZi5uYW1lPUNMQVNTLl9fbmFtZV9fCiAgICAKICAgIGRlZiBjbGFzc19pbml0KHNlbGYsX25hbWUsX2ZsYWdzLF93b3JrZGlyKToKICAgICAgICBzZWxmLnNlbGYubmFtZT1fbmFtZQogICAgICAgIAogICAgICAgIHNlbGYuc2VsZi5mbGFncz1nZXRfdmFsdWUoX2ZsYWdzLFtdKQogICAgICAgIAogICAgICAgIGlmIG5vdCBvcy5wYXRoLmlzZGlyKGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0iKToKICAgICAgICAgICAgIHJhaXNlIERvZXNOb3RFeGlzdCgpCiAgICAgICAgICAgICByZXR1cm4KICAgICAgICAgICAgIAogICAgICAgIHdyYXBfYWxsX21ldGhvZHNfaW5fY2xhc3Nfd2l0aF9jaGRpcl9jb250ZXh0bWFuYWdlcihzZWxmLnNlbGYsZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfSIpCiAgICAgICAgc2VsZi5zZWxmLndvcmtkaXI9X3dvcmtkaXIKICAgICAgICAKICAgICAgICBzZWxmLnNlbGYuZ2xvYmFscz1HTE9CQUxTLmNvcHkoKQogICAgICAgIHNlbGYuc2VsZi5nbG9iYWxzLnVwZGF0ZShleHBvcnRfbWV0aG9kc19mcm9tX3NlbGYoc2VsZi5zZWxmKSkKICAgICAgICAKICAgIGRlZiBzdG9wKHNlbGYpOgogICAgICAgIGlmICJTdG9wcGVkIiBpbiBzZWxmLnNlbGYuU3RhdHVzKCk6CiAgICAgICAgICAgIHJldHVybiBmIntzZWxmLm5hbWV9IHtzZWxmLnNlbGYubmFtZX0gaXMgYWxyZWFkeSBzdG9wcGVkIgogICAgICAgIAogICAgICAgIGZvciBwaWQgaW4gc2VsZi5zZWxmLlBzKCJtYWluIik6CiAgICAgICAgICAgIGtpbGxfcHJvY2Vzc19ncmFjZWZ1bGx5KHBpZCkKICAgICAgICAKICAgICAgICBmb3IgZW5kaW5nIGluIFsibG9nIiwibG9jayJdOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgIG9zLnJlbW92ZShmIntURU1QRElSfS97c2VsZi5uYW1lLmxvd2VyKCl9X3tzZWxmLnNlbGYubmFtZX0ue2VuZGluZ30iKQogICAgICAgICAgICBleGNlcHQgRmlsZU5vdEZvdW5kRXJyb3I6CiAgICAgICAgICAgICAgICBwYXNzCgogICAgZGVmIHJlc3RhcnQoc2VsZik6CiAgICAgICAgcmV0dXJuIFtzZWxmLnNlbGYuU3RvcCgpLHNlbGYuc2VsZi5TdGFydCgpXQogICAgCiAgICBkZWYgZ2V0X21haW5fcHJvY2VzcyhzZWxmKToKICAgICAgICBpZiBub3Qgb3MucGF0aC5pc2ZpbGUoZiJ7VEVNUERJUn0ve3NlbGYubmFtZS5sb3dlcigpfV97c2VsZi5zZWxmLm5hbWV9LmxvY2siKToKICAgICAgICAgICAgICAgIHJldHVybiBbXQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHJldHVybiBsaXN0KG1hcChpbnQsW18gZm9yIF8gaW4gc2hlbGxfY29tbWFuZChbImxzb2YiLCItdCIsIi13IixmIntURU1QRElSfS97c2VsZi5uYW1lLmxvd2VyKCl9X3tzZWxmLnNlbGYubmFtZX0ubG9jayJdKS5zcGxpdGxpbmVzKCldKSkKICAgIAogICAgZGVmIGxpc3Qoc2VsZik6CiAgICAgICAgcmV0dXJuIHNlbGYuc2VsZi5uYW1lCiAgICAgICAgCiAgICBkZWYgd29ya2RpcihzZWxmLHdvcmtfZGlyKToKICAgICAgICAjUmVtb3ZlIHRyYWlsaW5nIHNsYXNoZXMsIGJ1dCBvbmx5IGZvciBzdHJpbmdzIHRoYXQgYXJlIG5vdCAvCiAgICAgICAgaWYgd29ya19kaXIuZW5kc3dpdGgoJy8nKSBhbmQgbGVuKHdvcmtfZGlyKT4xOgogICAgICAgICAgICB3b3JrX2Rpcj13b3JrX2Rpcls6LTFdCiAgICAgICAgICAgIAogICAgICAgIGlmIHdvcmtfZGlyLnN0YXJ0c3dpdGgoIi8iKToKICAgICAgICAgICAgc2VsZi5zZWxmLndvcmtkaXI9d29ya19kaXIKICAgICAgICBlbHNlOiAgICAKICAgICAgICAgICAgc2VsZi5zZWxmLndvcmtkaXIrPScvJyt3b3JrX2RpcgogICAgICAgIAogICAgICAgICNSZW1vdmUgcmVwZWF0ZWQgLyBpbiB3b3JrZGlyCiAgICAgICAgc2VsZi5zZWxmLndvcmtkaXI9cmUuc3ViKHInKC8pXDErJywgcidcMScsc2VsZi5zZWxmLndvcmtkaXIpCgogICAgZGVmIHN0YXR1cyhzZWxmKToKICAgICAgICBpZiBvcy5wYXRoLmlzZmlsZShmIntURU1QRElSfS97c2VsZi5uYW1lLmxvd2VyKCl9X3tzZWxmLnNlbGYubmFtZX0ubG9nIik6CiAgICAgICAgICAgIHJldHVybiBbIlN0YXJ0ZWQiXQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHJldHVybiBbIlN0b3BwZWQiXQoKICAgIGRlZiBsb29wKHNlbGYsY29tbWFuZCxkZWxheT02MCk6CiAgICAgICAgaWYgaXNpbnN0YW5jZShjb21tYW5kLHN0cik6CiAgICAgICAgICAgIGRlZiBmdW5jKCk6CiAgICAgICAgICAgICAgICB3aGlsZSBUcnVlOgogICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZi5SdW4oY29tbWFuZCkKICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGYuV2FpdChkZWxheSkKICAgICAgICBlbHNlOgogICAgICAgICAgICBkZWYgZnVuYygpOgogICAgICAgICAgICAgICAgd2hpbGUgVHJ1ZTogIAogICAgICAgICAgICAgICAgICAgIGNvbW1hbmQoKQogICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZi5XYWl0KGRlbGF5KQogICAgICAgIHNlbGYuc2VsZi5SdW4oIiIpICNOZWVkZWQgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zIHdpdGggYSByYWNlIHRoYXQncyByaWdodCBhZnRlciAtLS0ganVzdCBydW4gc2VsZi5zZWxmLlJ1biBvbmNlCiAgICAgICAgdGhyZWFkaW5nLlRocmVhZCh0YXJnZXQ9ZnVuYyxkYWVtb249VHJ1ZSkuc3RhcnQoKQogICAgICAgCiAgICBkZWYga2lsbF9hdXhpbGlhcnlfcHJvY2Vzc2VzKHNlbGYpOgogICAgICAgIHdoaWxlIHNlbGYuc2VsZi5QcygiYXV4aWxpYXJ5IikhPVtdOiAjSWYgbmV3IHByb2Nlc3NlcyB3ZXJlIHN0YXJ0ZWQgZHVyaW5nIGFuIGl0ZXJhdGlvbiwgZ28gb3ZlciBpdCBhZ2FpbiwgdW50aWwgeW91IGtpbGxlZCB0aGVtIGFsbAogICAgICAgICAgICBmb3IgcGlkIGluIHNlbGYuc2VsZi5QcygiYXV4aWxpYXJ5Iik6CiAgICAgICAgICAgICAgICBraWxsX3Byb2Nlc3NfZ3JhY2VmdWxseShwaWQpCiAgICAgICAgICAgICAgICAKICAgIGRlZiBsb2coc2VsZik6CiAgICAgICAgc2hlbGxfY29tbWFuZChbImxlc3MiLCIrRyIsIi1mIiwiLXIiLGYie1RFTVBESVJ9L3tzZWxmLm5hbWUubG93ZXIoKX1fe3NlbGYuc2VsZi5uYW1lfS5sb2ciXSxzdGRvdXQ9Tm9uZSkKICAgIAogICAgZGVmIGRlbGV0ZShzZWxmKToKICAgICAgICBzZWxmLnNlbGYuU3RvcCgpCiAgICAgICAgc2h1dGlsLnJtdHJlZShmIntST09UfS97c2VsZi5zZWxmLm5hbWV9IikKICAgIAogICAgZGVmIHdhdGNoKHNlbGYpOgogICAgICAgIHRyeToKICAgICAgICAgICAgc2hlbGxfY29tbWFuZChbInRhaWwiLCItZiIsIi0tZm9sbG93PW5hbWUiLGYie1RFTVBESVJ9L3tzZWxmLm5hbWUubG93ZXIoKX1fe3NlbGYuc2VsZi5uYW1lfS5sb2ciXSxzdGRvdXQ9Tm9uZSkKICAgICAgICBleGNlcHQgS2V5Ym9hcmRJbnRlcnJ1cHQ6CiAgICAgICAgICAgIHBhc3MKICAgIAoK').decode("utf-8"),utils_module.__dict__)
sys.modules["utils"]=utils_module

import utils

utils.GLOBALS=globals()

SHELL_CWD=os.environ.get("PWD")

#Helper functions  
def flatten(*args, **kwargs):
    return utils.flatten_list(*args, **kwargs)

def print_result(*args, **kwargs):
    return utils.print_list(*args, **kwargs)

def convert_colon_string_to_directory(string):
    string=utils.split_string_by_char(string,char=":")
    if string[0]=="root":
        string=string[1] #The directory is just the absolute path in the host
    elif len(string)==1:
        string=string[0] # No container was specified, so assume "root"
    else:
        string=f"{utils.ROOT}/{string[0]}/diff{string[1]}" # Container was specified, so use it
    string=os.path.expanduser(string)
    return string
    
def load_dependencies(self,layer):
    with open(f"{utils.ROOT}/{layer}/container-compose.py") as fh:        
       root = ast.parse(fh.read())
       for node in ast.iter_child_nodes(root):
           if isinstance(node, ast.Expr) and isinstance(node.value,ast.Call):
               function=node.value.func.id
               if function in ["Layer","Base","Env","Shell"]:
                   arguments=[eval(ast.unparse(val)) for val in node.value.args]
                   getattr(self,function)(*arguments) #Run function

def chroot_command(self,command):
    if self.namespaces.user:
        result = ["unshare",f"--map-user={self.uid}",f"--map-group={self.gid}","--root=merged"] #Unshare is available so use it  
    else:
        result = ["chroot",f"--userspec={self.uid}:{self.gid}", "merged"] # Unshare does not exist, so use chroot
        
    result+=[f"{self.shell}","-c",f"{self.env}; cd {self.workdir}; {command}"]
    
    
    if self.namespaces.net:
        if not self.build:
            result=["sudo","ip","netns","exec",self.netns,"sudo","-u",getpass.getuser()]+result
    
    if sys.platform!="cygwin" and not self.namespaces.user:
        result=["sudo"]+result
        
    return result
    
def remove_empty_folders_in_diff():
    walk = list(os.walk("diff"))
    for path, _, _ in walk[::-1]:
        if not path.startswith("diff/.unionfs"):
            if len(os.listdir(path)) == 0:
                os.rmdir(path)
                
def str2bool(v):
  return v.lower() in ("yes", "true", "t", "1")
  
class Container:
    def __init__(self,_name,_flags=None,_unionopts="diff=RW",_workdir='/',_env=None,_uid=None,_gid=None,_shell=None):
        self.Class = utils.Class(self)
        self.Class.class_init(_name,_flags,_workdir)
        
        self.base="void"
        
        self.unionopts=utils.get_value(_unionopts,"diff=RW")
        
        self.env=utils.get_value(_env,f"""export PATH=/bin:/usr/sbin:/sbin:/usr/bin HOME=$(eval echo "~$(whoami)")""")
        
        #Whether we mounted dev, proc, etc.
        self.mounted_special=False
        
        self.namespaces=types.SimpleNamespace(user=str2bool(os.getenv("CONTAINER_USER_NAMESPACES","0")),net=str2bool(os.getenv("CONTAINER_NET_NAMESPACES","0")))
        
        self.workdir=_workdir
        
        
        self.uid=utils.get_value(_uid,0 if self.namespaces.user else os.getuid())
        self.gid=utils.get_value(_gid,0 if self.namespaces.user else os.getgid())
        
        self.shell=utils.get_value(_shell,"/bin/bash")
        
        self.temp_layers=[]
        
        self.hardlinks=[]
        
        self.build=False
        
        self.ports=[]
        if self.namespaces.net:
            self.netns=f"{self.name}-netns"
            self.veth_pair=types.SimpleNamespace(netns=types.SimpleNamespace(name=f"{self.name}-veth0"),host=types.SimpleNamespace(name=f"{self.name}-veth1"))
            
            while True:
                cidr=[random.randint(0,255),random.randint(0,255)]
                if any(f"{cidr[0]}.{cidr[1]}.0.1/24" in _ for _ in utils.shell_command(["ip","addr"],stderr=subprocess.DEVNULL)): #Check if CIDR range is already taken
                    continue
                else:
                    self.veth_pair.host.cidr=f"{cidr[0]}.{cidr[1]}.0.1/24"
                    self.veth_pair.netns.cidr=f"{cidr[0]}.{cidr[1]}.0.2/24"
                    break
            
        
        
    #Functions
    def Run(self,command="",pipe=False):
        if self.build:
            if command.strip()!="":
                print(f"Command: {command}")
        self.Base(self.base)
        #Only mount if this is the first Run called, where the base hasn't been added to unionopts
        if not self.unionopts.endswith(f":{utils.ROOT}/{self.base}/diff=RO"):
            self.unionopts+=f":{utils.ROOT}/{self.base}/diff=RO"
            
            #Prevent merged from being mounted multiple times
            if not os.path.ismount("merged"):
                utils.shell_command(["unionfs","-o","allow_other,cow,hide_meta_files",f"{self.unionopts}","merged"])
               
        #Mount dev,proc, etc. over the unionfs to deal with mmap bugs (fuse may be patched to deal with this natively so I can just mount on the diff directory, but for now, this is what is needed)
        if not self.mounted_special:
            for dir in ["dev","proc"]:
                if not os.path.ismount(f"merged/{dir}"):
                    #Use bind mounts for special mounts, as bindfs has too many quirks (and I'm using sudo regardless)
                    if sys.platform=="darwin":
                        #MacOS doesn't have bind-mounts
                        fstype=utils.shell_command(["stat","-f","-c","%T",f"/{dir}"],stderr=subprocess.DEVNULL)
                        utils.shell_command(["sudo", "mount", "-t", fstype, fstype, f"merged/{dir}"])
                    elif sys.platform=="cygwin":
                        #Cygwin doesn't have rbind
                        utils.shell_command(["mount","-o","bind",f"/{dir}",f"merged/{dir}"])
                    else:
                        utils.shell_command(["sudo","mount","--rbind",f"/{dir}",f"merged/{dir}"])
                   
            self.mounted_special=True
            
        with open(f"{utils.TEMPDIR}/container_{self.name}.log","a+") as log_file:
            log_file.write(f"Command: {command}\n")
            log_file.flush()
            
            #Pipe output to variable
            if pipe:
                stdout=subprocess.PIPE
                stderr=subprocess.DEVNULL
            #Print output to file
            else:
                stdout=log_file
                stderr=subprocess.STDOUT
            
            return utils.shell_command(chroot_command(self,command),stdout=stdout,stderr=stderr)
            
    
    def Ps(self,process=None):
        if process=="main" or ("--main" in self.flags):
            return self.Class.get_main_process()
        elif process=="auxiliary" or ("--auxiliary" in self.flags):
            if not os.path.isdir("merged"):
                return []
            processes=[_ for _ in utils.shell_command(["lsof","-t","-w","--","merged"]).splitlines()]
            return list(map(int,processes))
    
    def Mount(self,IN,OUT):
        IN=convert_colon_string_to_directory(IN)
        if os.path.isdir(IN):
            try:
                os.makedirs(f"diff{OUT}",exist_ok=True)
            except FileExistsError:
                os.remove(f"diff{OUT}")
                os.makedirs(f"diff{OUT}",exist_ok=True)
            if not os.path.ismount(f"diff{OUT}"):
                utils.shell_command(["bindfs",IN,f"diff{OUT}"]) #Only use bindfs 1.15.1
        else:
            try:
                os.link(IN,f"diff{OUT}")
            except FileExistsError:
                os.remove(f"diff{OUT}")
                os.link(IN,f"diff{OUT}")
            self.hardlinks.append(f"diff{OUT}")
            
    def Copy(self,src,dest):
        #Relative directory
        if not dest.startswith("/"):
            dest=f"diff{self.workdir}/{dest}"
        
        #Absolute directory
        else:
            dest=f"diff{dest}"
        
        src=convert_colon_string_to_directory(src)
        #Relative directory
        if not src.startswith("/"):
            src=f"{SHELL_CWD}/{src}"
            
        #Remove trailing slashes, in order to prevent gotchas with cp
        if src.endswith("/"):
            src=src[:-1]
        if dest.endswith("/"):
            dest=dest[:-1]
        
        #print(f"cp -a {src} {dest}")                   
        cp_error=utils.shell_command(["cp","-a",f"{src}",f"{dest}"])
        if "cp: cannot create" in cp_error:
            #dest does not exist, so create its parent's folder
            os.makedirs(os.path.dirname(dest),exist_ok=True)
            utils.shell_command(["cp","-a",f"{src}",f"{dest}"])

    def Loop(self,*args, **kwargs):
        self.Class.loop(*args, **kwargs)
        #Run(f'(while true; do "{command}"; sleep {delay}; done)')
        
    def Base(self,base):
        
        #Effectively make subsequent Bases a no-op
        if not self.unionopts.endswith(f":{utils.ROOT}/{self.base}/diff=RO"):
            self.base=base
        load_dependencies(self,base)
    def Wait(self,*args, **kwargs):
        utils.wait(*args, **kwargs)

    def Layer(self,layer,mode="RO"):
        if self.build:
            if len(os.listdir(f"{utils.ROOT}/{layer}/diff"))<2:
                #Build layer if it doesn't exist
                self.__class__(layer).Build()
                #utils.shell_command(["container","build",layer])
                self.temp_layers.append(layer) #Layer wasn't needed before so we can delete it after
        load_dependencies(self,layer)
        self.unionopts+=f":{utils.ROOT}/{layer}/diff={mode}"
    
    def Workdir(self,*args, **kwargs):
        self.Class.workdir(*args, **kwargs)
        os.makedirs(f"diff{self.workdir}",exist_ok=True)
        self.Update("workdir")
    
    def Env(self,*args, **kwargs):
        self.env=utils.add_environment_variable_to_string(self.env,*args, **kwargs)
        self.Update("env")
    
    def User(self,user=""):
        if not self.namespaces.user:
            return
        if user=="":
            self.uid=os.getuid()
            self.gid=os.getgid()
        else:
            user=utils.split_string_by_char(user,char=":")
            if len(user)==1:
                user.append(user[0]) #Make group the same as user if it is not available
            if user[0].isnumeric():
                self.uid=user[0]
            else:
                self.uid=int(self.Run(f"id -u {user[0]}",pipe=True))
                #self.uid=pwd.getpwnam(user[0])[2]
            
            if user[1].isnumeric():
                self.gid=user[1]
            else:
                self.gid=int(self.Run(f"id -g {user[1]}",pipe=True))
                #self.gid=pwd.getpwnam(user[1])[2]
        self.Update(["uid","gid"])
    
    def Shell(self,shell):
        self.shell=shell
        self.Update("shell")        
    
    def Volume(self,name,path):
        name=utils.split_string_by_char(name,char=":")
        
        #Allow to use volumes from other containers
        if len(name)==1:
            name.insert(0,self.name)
        volume_path=f"{utils.ROOT}/{name[0]}/Volumes/{name[1]}"
        
        self.Mount(volume_path,path)
        
    def Update(self,keys):
        if self.build:
            return #No lock file when building --- no need for it
        if isinstance(keys,str):
            keys=[keys]
        
        with open(f"{utils.TEMPDIR}/container_{self.name}.lock","r") as f:
            data=json.load(f)
            
        for key in keys:
            data[key]=getattr(self,key)
        
        with open(f"{utils.TEMPDIR}/container_{self.name}.lock","w+") as f:
            json.dump(data,f)
             
    def Exit(self,a,b):
        self.Class.kill_auxiliary_processes()
        
        #Unmount dev,proc, etc. if directory exists
        if os.path.isdir("merged"):
            for dir in os.listdir("merged"):
                if os.path.ismount(f"merged/{dir}"):
                
                    utils.shell_command(["sudo","mount","--make-rslave",f"merged/{dir}"])
                    utils.shell_command(["sudo","umount","-R","-l",f"merged/{dir}"])
                    
        
        diff_directories=[utils.split_string_by_char(_," ")[2] for _ in utils.shell_command(["mount"]).splitlines() if f"{utils.ROOT}/{self.name}/diff" in _]
        for dir in diff_directories:
             utils.shell_command(["umount","-l",dir])
             utils.shell_command(["rm","-rf",dir])
        utils.shell_command(["umount","-l","merged"])
    
        
        for hardlink in self.hardlinks:
            os.remove(hardlink) #Remove volume hardlinks when done
        
        utils.shell_command(["sudo","unlink","diff/etc/resolv.conf"])
        
        if self.namespaces.net:
            utils.shell_command(["sudo","ip","netns","del",self.netns])
        
        for port in self.ports:
            for pid in list(map(int,[_ for _ in utils.shell_command(["lsof","-t","-i",f":{port}"]).splitlines()])):
                utils.kill_process_gracefully(pid) #Kill socat(s)

        exit()
        
    def Port(self,_from,_to):
        if not self.namespaces.net:
            if _from==_to:
                return #If the ports are the same, don't socat it, since it will take up the port.
        for proto in ["tcp","udp"]:
            if self.namespaces.net:
               utils.shell_command(["socat", f"{proto}-listen:{_to},fork,reuseaddr,bind=127.0.0.1", f"""exec:'sudo ip netns exec {self.netns} socat STDIO "{proto}-connect:127.0.0.1:{_from}"',nofork"""], stdout=subprocess.DEVNULL,block=False)
            else:
               utils.shell_command(["socat", f"{proto}-l:{_to},fork,reuseaddr,bind=127.0.0.1", f"{proto}:127.0.0.1:{_from}"], stdout=subprocess.DEVNULL,block=False)
        self.ports.append(_to)
            
    #Commands      
    def Start(self):
        if "Started" in self.Status():
            return f"Container {self.name} is already started"
        
        #Fork process, so it can run in the background
        pid=os.fork()
        
        #If child, run code, then exit 
        if pid==0:
            self.Base(self.base)
            with open(f"{utils.TEMPDIR}/container_{self.name}.log","a+") as f:
                pass
            #Open a lock file so I can find it with lsof later
            self.lock=open(f"{utils.TEMPDIR}/container_{self.name}.lock","w+")
            
            with open(f"{utils.TEMPDIR}/container_{self.name}.lock","w+") as f:
                json.dump({},f)
            
            self.Update(["env","workdir", "uid","gid","shell"])
            
            signal.signal(signal.SIGTERM,self.Exit)
            
            if self.namespaces.net: #Start network namespace
                internet_interface=utils.shell_command("ip route get 8.8.8.8 | grep -Po '(?<=(dev ))(\S+)'",stderr=subprocess.DEVNULL,arbitrary=True) 
                commands=[
                    ['ip', 'netns', 'add', self.netns],
                    ['ip', 'netns', 'exec', self.netns, 'ip', 'link', 'set', 'lo', 'up'],
                    ['ip', 'link', 'add', self.veth_pair.host.name, 'type', 'veth', 'peer', 'name', self.veth_pair.netns.name],
                    ['ip', 'link', 'set', self.veth_pair.netns.name, 'netns', self.netns],
                    ['ip', 'addr', 'add', self.veth_pair.host.cidr, 'dev', self.veth_pair.host.name],
                    ['ip', 'netns', 'exec', self.netns, 'ip', 'addr', 'add', self.veth_pair.netns.cidr, 'dev', self.veth_pair.netns.name],
                    ['ip', 'link', 'set', self.veth_pair.host.name, 'up'],
                    ['ip', 'netns', 'exec', self.netns, 'ip', 'link', 'set', self.veth_pair.netns.name, 'up'],
                    ['sysctl', '-w', 'net.ipv4.ip_forward=1'],
                    ['iptables', '-A', 'FORWARD', '-o', internet_interface, '-i', self.veth_pair.host.name, '-j', 'ACCEPT'],
                    ['iptables', '-A', 'FORWARD', '-i', internet_interface, '-o', self.veth_pair.host.name, '-j', 'ACCEPT'],
                    ['iptables', '-t', 'nat', '-A', 'POSTROUTING', '-s', self.veth_pair.netns.cidr, '-o', internet_interface, '-j', 'MASQUERADE'],
                    ['ip', 'netns', 'exec', self.netns, 'ip', 'route', 'add', 'default', 'via', self.veth_pair.host.cidr[:-3]],
                    ["ip", "netns", "exec", self.netns, "sysctl", "-w", "net.ipv4.ip_unprivileged_port_start=1"]
                    ]
                 
                for command in commands:
                    utils.shell_command(["sudo"]+command,stdout=subprocess.DEVNULL)
                
                if not os.path.isdir("diff/etc"):
                    os.makedirs("diff/etc",exist_ok=True)
                utils.shell_command(["sudo","ln","-f","/etc/resolv.conf","diff/etc/resolv.conf"])
            #Run container-compose.py
            with open(f"{utils.ROOT}/{self.name}/container-compose.py") as f:
                code=f.read()
            exec(code,self.globals,locals())
            
            #Don't have to put Run() in container-compose.py just to start it
            self.Run()
            self.Wait()
            exit()
        
    def Build(self):
        self.Stop()
        self.build=True
        signal.signal(signal.SIGTERM,self.Exit)
        signal.signal(signal.SIGINT,self.Exit)
        with open("Containerfile.py") as f:
         code = compile(f.read(), 'Containerfile.py', 'exec')
         exec(code,self.globals,locals())
        self.Stop()
        remove_empty_folders_in_diff()
        for layer in self.temp_layers:
            #Clean layer if it was temporary
            self.__class__(layer).Clean()
            #utils.shell_command(["container","clean",layer])
        self.Exit(1,2)
        
       
    def Stop(self):
        return [self.Class.stop()]

    def Restart(self):
        return self.Class.restart()
    
    def Chroot(self):

        if "Stopped" in self.Status():
            stopped=True
        else:
            stopped=False
            with open(f"{utils.TEMPDIR}/container_{self.name}.lock","r") as f:
                data=json.load(f)
            
            for key in data:
                setattr(self,key,data[key]) #Read variables from .lock and populate self with them as a bootstrap
            
        command=self.shell #By default, run the shell
        for flag in self.flags:
            if flag.startswith("--run="):
                command=flag.split("=",1)[1]
        if stopped:
            self.Start()
            while not os.listdir("merged"): #Wait until merged directory has files before you attempt to chroot
                pass
        utils.shell_command(chroot_command(self,command),stdout=None)
        if stopped:
            self.Stop()
        
        if "--and-stop" in self.flags:
            return [self.Stop()]
    
    
    def List(self):
        return self.Class.list()

    def Init(self):
       
        os.makedirs(f"{utils.ROOT}/{self.name}",exist_ok=True)
        os.chdir(f"{utils.ROOT}/{self.name}")
        os.makedirs("diff",exist_ok=True)
        os.makedirs("merged",exist_ok=True)
        
        if '--temp' in self.flags:
            self.flags.append('--no-edit')
            self.flags.append('--only-chroot')
        with open(f"container-compose.py",'a'):
            pass
        
        if '--build' in self.flags:
            with open(f"Containerfile",'a'):
                pass
        
        if '--no-edit' not in self.flags:
            self.Edit()
        
        if utils.check_if_element_any_is_in_list(['--only-chroot','--and-chroot'],self.flags):
            return [self.Start(),self.Delete() if '--temp' in self.flags else None]

    def Edit(self):
        if '--build' in self.flags:
            utils.shell_command([os.getenv("EDITOR","vi"),f"{utils.ROOT}/{self.name}/Containerfile.py"],stdout=None)
        else:
            utils.shell_command([os.getenv("EDITOR","vi"),f"{utils.ROOT}/{self.name}/container-compose.py"],stdout=None)

    def Status(self):
        return self.Class.status()

    def Log(self):
        self.Class.log()
    
    def Clean(self):
        self.Stop()
        os.system(f"sudo rm -rf diff/*")
    
    def Delete(self):
        self.Stop()
        utils.shell_command(["sudo","rm","-rf",f"{utils.ROOT}/{self.name}"])
    
    def Watch(self):
        self.Class.watch()

utils.CLASS=Container

utils.ROOT=utils.get_root_directory()  
   
if __name__ == "__main__":
    NAMES,FLAGS,FUNCTION=utils.extract_arguments()
    
    for name in utils.list_items_in_root(NAMES, FLAGS):
        if FUNCTION!="init": #If you're running Init, skip this check, as you know it doesn't exist yet.
            try:
                item=utils.CLASS(name,FLAGS)
            except utils.DoesNotExist:
                print(f"Container {name} does not exist")
                continue
        result=utils.execute_class_method(item,FUNCTION)
        
        print_result(result)
        

    
