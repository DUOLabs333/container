#!/usr/bin/env python
import subprocess
import re
import sys
import os
import threading
import time
import ast
#import pwd, grp
import json



import types
import sys
import base64
utils_module=types.ModuleType("utils")
#setattr(utils_module,"__file__",__file__)
exec(base64.b64decode(b'aW1wb3J0IHN1YnByb2Nlc3MKaW1wb3J0IHJlCmltcG9ydCB0ZW1wZmlsZQppbXBvcnQgb3MKaW1wb3J0IHBhdGhsaWIKaW1wb3J0IHNpZ25hbCAKaW1wb3J0IHRpbWUKaW1wb3J0IHN5cwppbXBvcnQgdHlwaW5nCmltcG9ydCBzaHV0aWwKaW1wb3J0IHRocmVhZGluZwoKZGVmIGdldF90ZW1wZGlyKCk6CiAgICBpZiBvcy51bmFtZSgpLnN5c25hbWU9PSJEYXJ3aW4iOgogICAgICAgIHJldHVybiAiL3RtcCIKICAgIGVsc2U6CiAgICAgICAgcmV0dXJuIHRlbXBmaWxlLmdldHRlbXBkaXIoKQogICAgCgoKCmNsYXNzIERvZXNOb3RFeGlzdChFeGNlcHRpb24pOgogICAgcGFzcwoKZGVmIGdldF92YWx1ZSh2YXJpYWJsZSxkZWZhdWx0KToKCWlmIG5vdCB2YXJpYWJsZToKCQlyZXR1cm4gZGVmYXVsdAoJZWxzZToKCQlyZXR1cm4gdmFyaWFibGUKCmRlZiBnZXRfcm9vdF9kaXJlY3RvcnkoY2xhc3NfbmFtZSxyb290X3ZhcmlhYmxlPU5vbmUsZGVmYXVsdF92YWx1ZT1Ob25lKToKICAgIHJvb3RfdmFyaWFibGU9Z2V0X3ZhbHVlKHJvb3RfdmFyaWFibGUsZiJ7Y2xhc3NfbmFtZS51cHBlcigpfV9ST09UIikKICAgIGRlZmF1bHRfdmFsdWU9Z2V0X3ZhbHVlKGRlZmF1bHRfdmFsdWUsZiJ7b3MuZW52aXJvblsnSE9NRSddfS97Y2xhc3NfbmFtZS50aXRsZSgpfXMiKQogICAgcmV0dXJuIG9zLnBhdGguZXhwYW5kdXNlcihvcy5nZXRlbnYocm9vdF92YXJpYWJsZSxkZWZhdWx0X3ZhbHVlKSkKCmZvciB2YXIgaW4gWyJST09UIiwgIk5BTUVTIiwiVEVNUERJUiIsIkdMT0JBTFMiXToKICAgIGdsb2JhbHMoKVt2YXJdPU5vbmUgIAogICAgCiNST09UPU5vbmUKI05BTUVTPU5vbmUKI0ZMQUdTPU5vbmUKI0ZVTkNUSU9OPU5vbmUKI1RFTVBESVI9Tm9uZQoKZGVmIGxpc3RfaXRlbXNfaW5fcm9vdChuYW1lcyxmbGFncyxjbGFzc19uYW1lKToKICAgIEFsbD1bXyBmb3IgXyBpbiBzb3J0ZWQob3MubGlzdGRpcihST09UKSkgaWYgbm90IF8uc3RhcnRzd2l0aCgnLicpIF0KICAgIAogICAgZm9yIGZsYWcgaW4gWyJzdGFydGVkIiwic3RvcHBlZCIsImVuYWJsZWQiLCJkaXNhYmxlZCJdOgogICAgICAgIGlmICItLSIrZmxhZyBpbiBmbGFnczoKICAgICAgICAgICAgbmFtZXMrPVtfIGZvciBfIGluIEFsbCBpZiBmbGFnLnRpdGxlKCkgaW4gZXZhbChmIntjbGFzc19uYW1lfShfKS5TdGF0dXMoKSIsR0xPQkFMUyxsb2NhbHMoKSkgXQogICAgICAgICAgICBmbGFncy5yZW1vdmUoIi0tIitmbGFnKQoKICAgIGlmICItLWFsbCIgaW4gZmxhZ3M6CiAgICAgICAgbmFtZXMrPUFsbAogICAgICAgIGZsYWdzLnJlbW92ZSgiLS1hbGwiKQogICAgaWYgbmFtZXM9PVtdOgogICAgICAgIHByaW50KGYiTm8ge2NsYXNzX25hbWV9cyBzcGVjaWZpZWQhIikKICAgICAgICBleGl0KCkKICAgIHJldHVybiBuYW1lcwoKZGVmIGZsYXR0ZW5fbGlzdChpdGVtcyk6CiAgICAiIiJZaWVsZCBpdGVtcyBmcm9tIGFueSBuZXN0ZWQgaXRlcmFibGUuIiIiCiAgICBmb3IgeCBpbiBpdGVtczoKICAgICAgICBpZiBpc2luc3RhbmNlKHgsIHR5cGluZy5JdGVyYWJsZSkgYW5kIG5vdCBpc2luc3RhbmNlKHgsIChzdHIsIGJ5dGVzKSk6CiAgICAgICAgICAgIGZvciBzdWJfeCBpbiBmbGF0dGVuX2xpc3QoeCk6CiAgICAgICAgICAgICAgICB5aWVsZCBzdWJfeAogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHlpZWxkIHgKCmRlZiBwcmludF9saXN0KGwpOgogICAgZm9yIGVsZW1lbnQgaW4gbDoKICAgICAgICBpZiBlbGVtZW50IGlzIE5vbmU6CiAgICAgICAgICAgIHByaW50KGVuZD0nJykKICAgICAgICBlbHNlOgogICAgICAgICAgICBwcmludChlbGVtZW50KQoKZGVmIHNwbGl0X3N0cmluZ19ieV9jaGFyKHN0cmluZyxjaGFyPSc6Jyk6CiAgICBQQVRURVJOID0gcmUuY29tcGlsZShyZicnJygoPzpbXlx7Y2hhcn0iJ118IlteIl0qInwnW14nXSonKSspJycnKQogICAgcmV0dXJuIFtfIGZvciBfIGluIGxpc3QoUEFUVEVSTi5zcGxpdChzdHJpbmcpKSBpZiBfIG5vdCBpbiBbJycsIGNoYXJdXQoKCmRlZiBzaGVsbF9jb21tYW5kKGNvbW1hbmQsc3Rkb3V0PXN1YnByb2Nlc3MuUElQRSxzdGRlcnI9c3VicHJvY2Vzcy5TVERPVVQsYXJiaXRyYXJ5PUZhbHNlLGJsb2NrPVRydWUpOgogICAgcHJvY2VzcyA9IHN1YnByb2Nlc3MuUG9wZW4oY29tbWFuZCwgc3Rkb3V0PXN0ZG91dCwgc3RkZXJyPXN0ZGVycix1bml2ZXJzYWxfbmV3bGluZXM9VHJ1ZSxzaGVsbD1hcmJpdHJhcnkpCiAgICBpZiBibG9jazoKICAgICAgICByZXR1cm4gcHJvY2Vzcy5jb21tdW5pY2F0ZSgpWzBdCgpkZWYgd2FpdF91bnRpbF9waWRfZXhpdHMocGlkKToKICAgIAogICAgZGVmIHBpZF9leGlzdHMocGlkKTogICAKICAgICAgICAiIiIgQ2hlY2sgRm9yIHRoZSBleGlzdGVuY2Ugb2YgYSB1bml4IHBpZC4gIiIiCiAgICAgICAgdHJ5OgogICAgICAgICAgICBvcy5raWxsKHBpZCwgMCkKICAgICAgICBleGNlcHQgT1NFcnJvcjoKICAgICAgICAgICAgcmV0dXJuIEZhbHNlCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmV0dXJuIFRydWUKICAgICAgICAgICAgCiAgICB3aGlsZSBwaWRfZXhpc3RzKHBpZCk6CiAgICAgICAgdGltZS5zbGVlcCgwLjI1KQogICAgCmRlZiBleHRyYWN0X2FyZ3VtZW50cygpOgogICAgYXJndW1lbnRzPXN5cy5hcmd2WzE6XQogICAgdHJ5OgogICAgICAgIEZVTkNUSU9OPWFyZ3VtZW50c1swXQogICAgZXhjZXB0IEluZGV4RXJyb3I6CiAgICAgICAgcHJpbnQoIk5vIGZ1bmN0aW9uIHNwZWNpZmllZCEiKQogICAgICAgIGV4aXQoKQogICAgYXJndW1lbnRzPWFyZ3VtZW50c1sxOl0KICAgIAogICAgTkFNRVM9W10KICAgIEZMQUdTPWFyZ3VtZW50cwogICAgZm9yIGkgaW4gcmFuZ2UobGVuKGFyZ3VtZW50cykpOgogICAgICAgIGlmIG5vdCBhcmd1bWVudHNbaV0uc3RhcnRzd2l0aCgiLS0iKToKICAgICAgICAgICAgRkxBR1M9YXJndW1lbnRzWzppXQogICAgICAgICAgICBOQU1FUz1hcmd1bWVudHNbaTpdCiAgICAgICAgICAgIGJyZWFrCiAgICByZXR1cm4gKE5BTUVTLEZMQUdTLEZVTkNUSU9OKQoKZGVmIGFkZF9lbnZpcm9ubWVudF92YXJpYWJsZV90b19zdHJpbmcoc3RyaW5nLGVudl92YXIpOgogICAgcmV0dXJuIHN0cmluZytmIjsgZXhwb3J0IHtlbnZfdmFyfSIKCmRlZiB3YWl0KGRlbGF5PU5vbmUpOgogICAgdGhyZWFkaW5nLkV2ZW50KCkud2FpdCh0aW1lb3V0PWRlbGF5KQoKZGVmIGV4ZWN1dGVfY2xhc3NfbWV0aG9kKGNsYXNzX2luc3RhbmNlLGZ1bmN0aW9uKToKICAgIGlmIG5vdCBjYWxsYWJsZShnZXRhdHRyKGNsYXNzX2luc3RhbmNlLCBmdW5jdGlvbi50aXRsZSgpLE5vbmUpKToKICAgICAgICAgICAgcHJpbnQoZiJDb21tYW5kIHtmdW5jdGlvbn0gZG9lc24ndCBleGlzdCEiKQogICAgICAgICAgICBleGl0KCkKICAgIGVsc2U6CiAgICAgICAgcmV0dXJuIGxpc3QoZmxhdHRlbl9saXN0KFtnZXRhdHRyKGNsYXNzX2luc3RhbmNlLGZ1bmN0aW9uLnRpdGxlKCkpKCldKSkKCmRlZiBleHBvcnRfbWV0aG9kc19nbG9iYWxseShjbGFzc19uYW1lKToKICAgIGZvciBmdW5jIGluIFtmdW5jIGZvciBmdW5jIGluIGRpcihldmFsKGNsYXNzX25hbWUsR0xPQkFMUykpIGlmIGNhbGxhYmxlKGdldGF0dHIoZXZhbChjbGFzc19uYW1lLEdMT0JBTFMpLCBmdW5jKSkgYW5kIG5vdCBmdW5jLnN0YXJ0c3dpdGgoJ19fJyldOgogICAgICAgIGV4ZWMoZiJnbG9iYWwge2Z1bmN9IixHTE9CQUxTKQogICAgICAgIGV4ZWMoZiJ7ZnVuY30gPSB7Y2xhc3NfbmFtZS5sb3dlcigpfS57ZnVuY30iLEdMT0JBTFMpCgpkZWYgY2hlY2tfaWZfZWxlbWVudF9hbnlfaXNfaW5fbGlzdChlbGVtZW50cyxfbGlzdCk6CiAgICByZXR1cm4gYW55KF8gaW4gX2xpc3QgZm9yIF8gaW4gZWxlbWVudHMpCiAgICAKY2xhc3MgQ2xhc3M6CiAgICBkZWYgX19pbml0X18oc2VsZixjbGFzc19zZWxmLGNsYXNzX25hbWUpOgogICAgICAgIHNlbGYuc2VsZj1jbGFzc19zZWxmCiAgICAgICAgc2VsZi5uYW1lPWNsYXNzX25hbWUKICAgIAogICAgZGVmIGNsYXNzX2luaXQoc2VsZixfbmFtZSxfZmxhZ3MsX2Z1bmN0aW9uLF93b3JrZGlyKToKICAgICAgICBzZWxmLnNlbGYubmFtZT1fbmFtZQogICAgICAgIAogICAgICAgIHNlbGYuc2VsZi5mbGFncz1nZXRfdmFsdWUoX2ZsYWdzLFtdKQogICAgICAgIAogICAgICAgIHNlbGYuc2VsZi5mdW5jdGlvbj1nZXRfdmFsdWUoX2Z1bmN0aW9uLCIiKQogICAgICAgIAogICAgICAgIGlmIHNlbGYuc2VsZi5mdW5jdGlvbiBub3QgaW4gWyJpbml0Il06CiAgICAgICAgICAgIGlmIG5vdCBvcy5wYXRoLmlzZGlyKGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0iKToKICAgICAgICAgICAgICAgICByYWlzZSBEb2VzTm90RXhpc3QoKQogICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICBvcy5jaGRpcihmIntST09UfS97c2VsZi5zZWxmLm5hbWV9IikKICAgICAgICBzZWxmLnNlbGYud29ya2Rpcj1fd29ya2RpcgogICAgICAgIAogICAgZGVmIHN0b3Aoc2VsZik6CiAgICAgICAgaWYgIlN0b3BwZWQiIGluIHNlbGYuc2VsZi5TdGF0dXMoKToKICAgICAgICAgICAgcmV0dXJuIGYiU2VydmljZSB7c2VsZi5zZWxmLm5hbWV9IGlzIGFscmVhZHkgc3RvcHBlZCIKICAgICAgICAKICAgICAgICBmb3IgcHJvY2VzcyBpbiBbIm1haW4iLCAiYXV4aWxpYXJ5Il06CiAgICAgICAgICAgIGZvciBwaWQgaW4gc2VsZi5zZWxmLlBzKHByb2Nlc3MpOgogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIG9zLmtpbGwocGlkLHNpZ25hbC5TSUdURVJNKQogICAgICAgICAgICAgICAgICAgIHdhaXRfdW50aWxfcGlkX2V4aXRzKHBpZCkKICAgICAgICAgICAgICAgIGV4Y2VwdCBQcm9jZXNzTG9va3VwRXJyb3I6CiAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgIAogICAgZGVmIGNsZWFudXBfYWZ0ZXJfc3RvcChzZWxmKToKICAgICAgICBmb3IgZW5kaW5nIGluIFsibG9nIiwibG9jayJdOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgIG9zLnJlbW92ZShmIntURU1QRElSfS97c2VsZi5uYW1lfV97c2VsZi5zZWxmLm5hbWV9LntlbmRpbmd9IikKICAgICAgICAgICAgZXhjZXB0IEZpbGVOb3RGb3VuZEVycm9yOgogICAgICAgICAgICAgICAgcGFzcwoKICAgIGRlZiByZXN0YXJ0KHNlbGYpOgogICAgICAgIHJldHVybiBbc2VsZi5zZWxmLlN0b3AoKSxzZWxmLnNlbGYuU3RhcnQoKV0KICAgIAogICAgZGVmIGdldF9tYWluX3Byb2Nlc3Moc2VsZik6CiAgICAgICAgaWYgbm90IG9zLnBhdGguaXNmaWxlKGYie1RFTVBESVJ9L3tzZWxmLm5hbWV9X3tzZWxmLnNlbGYubmFtZX0ubG9jayIpOgogICAgICAgICAgICAgICAgcmV0dXJuIFtdCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmV0dXJuIGxpc3QobWFwKGludCxbX1sxOl0gZm9yIF8gaW4gc2hlbGxfY29tbWFuZChbImxzb2YiLCItRnAiLCItdyIsZiJ7VEVNUERJUn0ve3NlbGYubmFtZX1fe3NlbGYuc2VsZi5uYW1lfS5sb2NrIl0pLnNwbGl0bGluZXMoKV0pKQogICAgCiAgICBkZWYgbGlzdChzZWxmKToKICAgICAgICByZXR1cm4gc2VsZi5zZWxmLm5hbWUKICAgICAgICAKICAgIGRlZiB3b3JrZGlyKHNlbGYsd29ya19kaXIpOgogICAgICAgICNSZW1vdmUgdHJhaWxpbmcgc2xhc2hlcywgYnV0IG9ubHkgZm9yIHN0cmluZ3MgdGhhdCBhcmUgbm90IC8KICAgICAgICBpZiB3b3JrX2Rpci5lbmRzd2l0aCgnLycpIGFuZCBsZW4od29ya19kaXIpPjE6CiAgICAgICAgICAgIHdvcmtfZGlyPXdvcmtfZGlyWzotMV0KICAgICAgICAgICAgCiAgICAgICAgaWYgd29ya19kaXIuc3RhcnRzd2l0aCgiLyIpOgogICAgICAgICAgICBzZWxmLnNlbGYud29ya2Rpcj13b3JrX2RpcgogICAgICAgIGVsc2U6ICAgIAogICAgICAgICAgICBzZWxmLnNlbGYud29ya2Rpcis9Jy8nK3dvcmtfZGlyCiAgICAgICAgCiAgICAgICAgI1JlbW92ZSByZXBlYXRlZCAvIGluIHdvcmtkaXIKICAgICAgICBzZWxmLnNlbGYud29ya2Rpcj1yZS5zdWIocicoLylcMSsnLCByJ1wxJyxzZWxmLnNlbGYud29ya2RpcikKCiAgICBkZWYgZWRpdChzZWxmKToKICAgICAgICBpZiAiRW5hYmxlZCIgaW4gc2VsZi5zZWxmLlN0YXR1cygpOgogICAgICAgICAgICBzaGVsbF9jb21tYW5kKFtvcy5nZXRlbnYoIkVESVRPUiIsInZpIiksZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfS97c2VsZi5uYW1lfS5weSJdLHN0ZG91dD1Ob25lKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHNoZWxsX2NvbW1hbmQoW29zLmdldGVudigiRURJVE9SIiwidmkiKSxmIntST09UfS97c2VsZi5zZWxmLm5hbWV9Ly57c2VsZi5uYW1lfS5weSJdLHN0ZG91dD1Ob25lKQoKICAgIGRlZiBzdGF0dXMoc2VsZik6CiAgICAgICAgc3RhdHVzPVtdCiAgICAgICAgaWYgb3MucGF0aC5pc2ZpbGUoZiJ7VEVNUERJUn0ve3NlbGYubmFtZX1fe3NlbGYuc2VsZi5uYW1lfS5sb2ciKToKICAgICAgICAgICAgc3RhdHVzKz1bIlN0YXJ0ZWQiXQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHN0YXR1cys9WyJTdG9wcGVkIl0KICAgICAgICAKICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyhmIntST09UfS97c2VsZi5zZWxmLm5hbWV9L3tzZWxmLm5hbWV9LnB5Iik6CiAgICAgICAgICAgIHN0YXR1cys9WyJFbmFibGVkIl0KICAgICAgICBlbHNlOgogICAgICAgICAgICBzdGF0dXMrPVsiRGlzYWJsZWQiXQogICAgICAgIHJldHVybiBzdGF0dXMKICAgIAogICAgZGVmIGVuYWJsZShzZWxmKToKICAgICAgICBpZiAiRW5hYmxlZCIgaW4gc2VsZi5zZWxmLlN0YXR1cygpOgogICAgICAgICAgICByZXR1cm4gW2Yie3NlbGYubmFtZX0gaXMgYWxyZWFkeSBlbmFibGVkIl0KICAgICAgICBlbHNlOgogICAgICAgICAgICBvcy5yZW5hbWUoZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfS8ue3NlbGYubmFtZX0ucHkiLGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0ve3NlbGYubmFtZX0ucHkiKQogICAgICAgIAogICAgICAgIGlmICctLW5vdycgaW4gc2VsZi5zZWxmLmZsYWdzOgogICAgICAgICAgICByZXR1cm4gW3NlbGYuc2VsZi5TdGFydCgpXQoKICAgIGRlZiBsb29wKHNlbGYsY29tbWFuZCxkZWxheT02MCk6CiAgICAgICAgaWYgaXNpbnN0YW5jZShjb21tYW5kLHN0cik6CiAgICAgICAgICAgIGRlZiBmdW5jKCk6CiAgICAgICAgICAgICAgICB3aGlsZSBUcnVlOgogICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZi5SdW4oY29tbWFuZCkKICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGYuV2FpdChkZWxheSkKICAgICAgICBlbHNlOgogICAgICAgICAgICBkZWYgZnVuYygpOgogICAgICAgICAgICAgICAgd2hpbGUgVHJ1ZTogIAogICAgICAgICAgICAgICAgICAgIGNvbW1hbmQoKQogICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZi5XYWl0KGRlbGF5KQogICAgICAgIHRocmVhZGluZy5UaHJlYWQodGFyZ2V0PWZ1bmMsZGFlbW9uPVRydWUpLnN0YXJ0KCkKICAgICAgIAogICAgZGVmIGRpc2FibGUoc2VsZik6CiAgICAgICAgaWYgIkRpc2FibGVkIiBpbiBzZWxmLnNlbGYuU3RhdHVzKCk6CiAgICAgICAgICAgIHJldHVybiBbZiJ7c2VsZi5zZWxmLm5hbWV9IGlzIGFscmVhZHkgZGlzYWJsZWQiXQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIG9zLnJlbmFtZShmIntST09UfS97c2VsZi5zZWxmLm5hbWV9L3tzZWxmLm5hbWV9LnB5IixmIntST09UfS97c2VsZi5zZWxmLm5hbWV9Ly57c2VsZi5uYW1lfS5weSIpCiAgICAgICAgCiAgICAgICAgaWYgJy0tbm93JyBpbiBzZWxmLnNlbGYuZmxhZ3M6CiAgICAgICAgICAgIHJldHVybiBbc2VsZi5zZWxmLlN0b3AoKV0KCiAgICBkZWYgbG9nKHNlbGYpOgogICAgICAgIHNoZWxsX2NvbW1hbmQoWyJsZXNzIiwiK0ciLCItZiIsIi1yIixmIntURU1QRElSfS97c2VsZi5uYW1lfV97c2VsZi5zZWxmLm5hbWV9LmxvZyJdLHN0ZG91dD1Ob25lKQogICAgCiAgICBkZWYgZGVsZXRlKHNlbGYpOgogICAgICAgIHNlbGYuc2VsZi5TdG9wKCkKICAgICAgICBzaHV0aWwucm10cmVlKGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0iKQogICAgCiAgICBkZWYgd2F0Y2goc2VsZik6CiAgICAgICAgc2hlbGxfY29tbWFuZChbInRhaWwiLCItZiIsIi0tZm9sbG93PW5hbWUiLGYie1RFTVBESVJ9L3tzZWxmLm5hbWV9X3tzZWxmLnNlbGYubmFtZX0ubG9nIl0sc3Rkb3V0PU5vbmUpCiAgICAKCg==').decode("utf-8"),utils_module.__dict__)
sys.modules["utils"]=utils_module

import utils
CLASS_NAME="Container"

utils.ROOT=ROOT=utils.get_root_directory(CLASS_NAME)
utils.TEMPDIR=TEMPDIR=utils.get_tempdir()

NAMES,FLAGS,FUNCTION=utils.extract_arguments()

utils.NAMES=NAMES
utils.ROOT=ROOT
utils.GLOBALS=globals()

SHELL_CWD=os.environ.get("PWD")
PATH="PATH=/bin:/usr/sbin:/sbin:/usr/bin"

#Helper functions
def list_containers(*args, **kwargs):
    return utils.list_items_in_root(*args, FLAGS,CLASS_NAME,**kwargs)    

def flatten(*args, **kwargs):
    return utils.flatten_list(*args, **kwargs)

def print_result(*args, **kwargs):
    return utils.print_list(*args, **kwargs)

def convert_colon_string_to_directory(string):
    string=utils.split_string_by_char(string)
    if string[0]=="root":
        string=string[1] #The directory is just the absolute path in the host
    elif len(string)==1:
        string=string[0] # No container was specified, so assume "root"
    else:
        string=f"{ROOT}/{string[0]}/diff{string[1]}" # Container was specified, so use it
    string=os.path.expanduser(string)
    return string
    
def load_dependencies(layer):
    with open(f"{ROOT}/{layer}/container-compose.py") as fh:        
       root = ast.parse(fh.read())
       for node in ast.iter_child_nodes(root):
           if isinstance(node, ast.Expr) and isinstance(node.value,ast.Call):
               function=node.value.func.id
               if function in ["Layer","Base","Env"]:
                   arguments=[eval(ast.unparse(val)) for val in node.value.args]
                   globals()[function](*arguments)

def remove_empty_folders_in_diff():
    walk = list(os.walk("diff"))
    for path, _, _ in walk[::-1]:
        if not path.startswith("diff/.unionfs"):
            if len(os.listdir(path)) == 0:
                os.rmdir(path)
                
ContainerDoesNotExist=utils.DoesNotExist
class Container:
    def __init__(self,_name,_flags=None,_unionopts=None,_workdir='/',_env=None,_function=None,_uid=None,_gid=None,_shell=None):
        self.Class = utils.Class(self,CLASS_NAME.lower())
        self.Class.class_init(_name,_flags,_function,_workdir)
        
        self.base="void"
        
        self.unionopts=utils.get_value(_unionopts,"diff=RW")
        
        self.env=utils.get_value(_env,f"export {PATH}")
        
        #Whether we mounted dev, proc, etc.
        self.mounted_special=False
            
        self.workdir=_workdir
        
        self.uid=utils.get_value(_uid,os.getuid())
        self.gid=utils.get_value(_gid,os.getgid())
        
        self.shell=utils.get_value(_shell,"/bin/bash")
        
        self.temp_layers=[]
    
    #Functions
    def Run(self,command="",pipe=False):
        if self.function=="build":
            if command.strip()!="":
                print(f"Command: {command}")
        self.Base(self.base)
        #Only mount if this is the first Run called, where the base hasn't been added to unionopts
        if not self.unionopts.endswith(f":{ROOT}/{self.base}/diff=RO"):
            self.unionopts+=f":{ROOT}/{self.base}/diff=RO"
            
            #Prevent merged from being mounted multiple times
            if not os.path.ismount("merged"):
                utils.shell_command(["unionfs","-o","allow_other,cow,hide_meta_files",f"{self.unionopts}","merged"])
               
        #Mount dev,proc, etc. over the unionfs to deal with mmap bugs (fuse may be patched to deal with this natively, but for now, this is what is needed)
        if not self.mounted_special:
            for dir in ["dev","proc","sys","run"]:
                if not os.path.ismount(f"merged/{dir}"):
                    #Use bind mounts for special mounts, as bindfs has too many quirks (and I'm using sudo regardless)
                    #mount -o rbind works too
                    #utils.shell_command(f"sudo bindfs -o direct_io,allow_other,dev /{dir} merged/{dir}")
                    utils.shell_command(["sudo","mount","--rbind",f"/{dir}",f"merged/{dir}"])
                   
            self.mounted_special=True
            
        with open(f"{TEMPDIR}/container_{self.name}.log","a+") as log_file:
            log_file.write(f"Command: {command}\n")
            log_file.flush()
            
            #Pipe output to variable
            if pipe:
                stdout=subprocess.PIPE
                stderr=subprocess.DEVNULL
            #Print output to file
            else:
                stdout=log_file
                stderr=subprocess.STDOUT
            return utils.shell_command(["sudo","nohup","chroot",f"--userspec={self.uid}:{self.gid}", "merged",f"{self.shell}","-c",f"{self.env}; cd {self.workdir}; {command}"],stdout=stdout,stderr=stderr)
            
    
    def Ps(self,process=None):
        if process=="main" or ("--main" in self.flags):
            return self.Class.get_main_process()
        elif process=="auxiliary" or ("--auxiliary" in self.flags):
            if not os.path.isdir("merged"):
                return []
            processes=[_[1:] for _ in utils.shell_command(["lsof","-Fp","-w","--","merged"]).splitlines()]
            return list(map(int,processes))
    
    def Mount(self,IN,OUT):
        os.makedirs(f"diff{OUT}",exist_ok=True)
        if not os.path.ismount(f"diff{OUT}"):
            IN=convert_colon_string_to_directory(IN)
            utils.shell_command(["bindfs",IN,f"diff{OUT}"])
    
    def Copy(self,src,dest):
        #Relative directory
        if not dest.startswith("/"):
            dest=f"diff{self.workdir}/{dest}"
        
        #Absolute directory
        else:
            dest=f"diff{dest}"
        
        src=convert_colon_string_to_directory(src)
        #Relative directory
        if not src.startswith("/"):
            src=f"{SHELL_CWD}/{src}"
            
        #Remove trailing slashes, in order to prevent gotchas with cp
        if src.endswith("/"):
            src=src[:-1]
        if dest.endswith("/"):
            dest=dest[:-1]
        
        #print(f"cp -a {src} {dest}")                   
        cp_error=utils.shell_command(["cp","-a",f"{src}",f"{dest}"])
        if "cp: cannot create" in cp_error:
            #dest does not exist, so create its parent's folder
            os.makedirs(os.path.dirname(dest),exist_ok=True)
            utils.shell_command(["cp","-a",f"{src}",f"{dest}"])

    def Loop(self,*args, **kwargs):
        self.Class.loop(*args, **kwargs)
        #Run(f'(while true; do "{command}"; sleep {delay}; done)')
        
    def Base(self,base):
        
        #Effectively make subsequent Bases a no-op
        if not self.unionopts.endswith(f":{ROOT}/{self.base}/diff=RO"):
            self.base=base
    
    def Wait(self,*args, **kwargs):
        utils.wait(*args, **kwargs)

    def Layer(self,layer,mode="RO"):
        if self.function=="build":
            if len(os.listdir(f"{ROOT}/{layer}/diff"))<2:
                utils.shell_command(["container","build",layer]) #Build layer if it doesn't exist
                self.temp_layers.append(layer) #Layer wasn't needed before so we can delete it after
        load_dependencies(layer)
        self.unionopts+=f":{ROOT}/{layer}/diff={mode}"
    
    def Workdir(self,*args, **kwargs):
        self.Class.workdir(*args, **kwargs)
        os.makedirs(f"diff{self.workdir}",exist_ok=True)
        self.Update("workdir")
    
    def Env(self,*args, **kwargs):
        self.env=utils.add_environment_variable_to_string(self.env,*args, **kwargs)
        self.Update("env")
    
    def User(self,user=""):
        if user=="":
            self.uid=os.getuid()
            self.gid=os.getgid()
        else:
            user=utils.split_string_by_char(user,char=":")
            if len(user)==1:
                user.append(user[0]) #Make group the same as user if it is not available
            if user[0].isnumeric():
                self.uid=user[0]
            else:
                self.uid=int(self.Run(f"id -u {user[0]}",pipe=True))
                #self.uid=pwd.getpwnam(user[0])[2]
            
            if user[1].isnumeric():
                self.gid=user[1]
            else:
                self.gid=int(self.Run(f"id -g {user[1]}",pipe=True))
                #self.gid=pwd.getpwnam(user[1])[2]
        self.Update(["uid","gid"])
    
    def Shell(self,shell):
        self.shell=shell
        self.Update("shell")        
    
    def Update(self,keys):
        if self.function=="build":
            return #No lock file when building --- no need for it
        if isinstance(keys,str):
            keys=[keys]
        
        with open(f"{TEMPDIR}/container_{self.name}.lock","r") as f:
            data=json.load(f)
            
        for key in keys:
            data[key]=getattr(self,key)
        
        with open(f"{TEMPDIR}/container_{self.name}.lock","w+") as f:
            json.dump(data,f)  
        
    #Commands      
    def Start(self):
        
        self.Base(self.base)
        if "Started" in self.Status():
            return f"Container {self.name} is already started"
        
        #Fork process, so it can run in the background
        pid=os.fork()
        
        #If child, run code, then exit 
        if pid==0:
            #Open a lock file so I can find it with lsof later
            self.lock=open(f"{TEMPDIR}/container_{self.name}.lock","w+")
            
            with open(f"{TEMPDIR}/container_{self.name}.lock","w+") as f:
                json.dump({},f)
            
            self.Update(["env","workdir", "uid","gid","shell"])
            
            #Run *service.py
            with open(f"{ROOT}/{self.name}/container-compose.py") as f:
                code=f.read()
            exec(code,globals(),locals())
            
            #Don't have to put Run() in container-compose.py just to start it
            self.Run()
            self.Wait()
            exit()
        
    def Build(self):
        self.Stop()
        with open("Containerfile") as f:
         code = compile(f.read(), 'Containerfile', 'exec')
         exec(code,globals(),locals())
        self.Stop()
        remove_empty_folders_in_diff()
        for layer in self.temp_layers:
            utils.shell_command(["container","clean",layer]) #Clean layer if it was temporary
        
       
    def Stop(self):
        output=[self.Class.stop()]
        #Unmount dev,proc, etc. if directory exists
        if os.path.isdir("merged"):
            for dir in os.listdir("merged"):
                if os.path.ismount(f"merged/{dir}"):
                
                    utils.shell_command(["sudo","mount","--make-rslave",f"merged/{dir}"])
                    utils.shell_command(["sudo","umount","-R","-l",f"merged/{dir}"])
                    
        
        diff_directories=[utils.split_string_by_char(_," ")[2] for _ in utils.shell_command(["mount"]).splitlines() if f"{ROOT}/{self.name}/diff" in _]
        for dir in diff_directories:
             utils.shell_command(["umount","-l",f"{dir}"])
        utils.shell_command(["umount","-l","merged"])
    
    
        self.Class.cleanup_after_stop()
        return output

    def Restart(self):
        return self.Class.restart()
    
    def Chroot(self):
        if "Stopped" in self.Status():
            return ["Can't chroot into stopped container!"]
        
        with open(f"{TEMPDIR}/container_{self.name}.lock","r") as f:
            data=json.load(f)
        
        command=None
        for flag in self.flags:
            if flag.startswith("--run="):
                command=flag.split("=",1)[1]
        
        if not command:
            command=""
        else:
            command=f"-c '{command}'"
        for key in data:
            setattr(self,key,data[key])
        utils.shell_command(["sudo","chroot",f"--userspec={self.uid}:{self.gid}",f"{ROOT}/{self.name}/merged","/bin/sh","-c",f"""{self.env}; cd {self.workdir}; {self.shell} {command}"""],stdout=None)
        
        #For some reason, only os.system actually activates the PS1
        #os.system(f"sudo chroot --userspec={self.uid}:{self.gid} {ROOT}/{self.name}/merged /bin/sh -c '{self.env}; cd {self.workdir}; {self.shell}'")
        
        if "--and-stop" in self.flags:
            return [self.Stop()]
    
    
    def List(self):
        return self.Class.list()

    def Init(self):
       
        os.makedirs(f"{ROOT}/{self.name}",exist_ok=True)
        os.chdir(f"{ROOT}/{self.name}")
        os.makedirs("diff",exist_ok=True)
        os.makedirs("merged",exist_ok=True)
        
        if '--temp' in self.flags:
            self.flags.append('--no-edit')
            self.flags.append('--only-chroot')
        with open(f"container-compose.py",'a'):
            pass
        
        if '--build' in self.flags:
            with open(f"Containerfile",'a'):
                pass
        
        if '--no-edit' not in self.flags:
            self.Edit()
        
        if utils.check_if_element_any_is_in_list(['--only-chroot','--and-chroot'],self.flags):
            return [self.Start(),self.Delete() if '--temp' in self.flags else None]

    def Edit(self):
        if '--build' in self.flags:
            utils.shell_command([os.getenv("EDITOR","vi"),f"{ROOT}/{self.name}/Containerfile"],stdout=None)
        else:
            utils.shell_command([os.getenv("EDITOR","vi"),f"{ROOT}/{self.name}/container-compose.py"],stdout=None)

    def Status(self):
        return self.Class.status()

    def Log(self):
        self.Class.log()
    
    def Clean(self):
        self.Stop()
        os.system(f"sudo rm -rf diff/*")
    
    def Delete(self):
        self.Stop()
        utils.shell_command(["sudo","rm","-rf",f"{ROOT}/{self.name}"])
    
    def Watch(self):
        self.Class.watch()

NAMES=list_containers(utils.NAMES)
for name in NAMES:
    
    BASE="void"
    UNIONOPTS="diff=RW"
    
    try:
        container=Container(name,_flags=FLAGS,_unionopts=UNIONOPTS,_function=FUNCTION)
    except ContainerDoesNotExist:
        print(f"Container {name} does not exist")
        continue
        
    utils.export_methods_globally(CLASS_NAME)
    result=utils.execute_class_method(eval(f"{CLASS_NAME.lower()}"),FUNCTION)
    
    print_result(result)
        

    
