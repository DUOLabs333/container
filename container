#!/usr/bin/env python
import subprocess
import re
import sys
import os
import threading
import time
import ast
#import pwd, grp
import json
import hashlib
import signal



import types
import sys
import base64
utils_module=types.ModuleType("utils")
#setattr(utils_module,"__file__",__file__)
exec(base64.b64decode(b'aW1wb3J0IHN1YnByb2Nlc3MKaW1wb3J0IHJlCmltcG9ydCB0ZW1wZmlsZQppbXBvcnQgb3MKaW1wb3J0IHBhdGhsaWIKaW1wb3J0IHNpZ25hbCAKaW1wb3J0IHRpbWUKaW1wb3J0IHN5cwppbXBvcnQgdHlwaW5nCmltcG9ydCBzaHV0aWwKaW1wb3J0IHRocmVhZGluZwppbXBvcnQgY29udGV4dGxpYgoKZGVmIGdldF90ZW1wZGlyKCk6CiAgICBpZiBvcy51bmFtZSgpLnN5c25hbWU9PSJEYXJ3aW4iOgogICAgICAgIHJldHVybiAiL3RtcCIKICAgIGVsc2U6CiAgICAgICAgcmV0dXJuIHRlbXBmaWxlLmdldHRlbXBkaXIoKQogICAgCgoKCmNsYXNzIERvZXNOb3RFeGlzdChFeGNlcHRpb24pOgogICAgcGFzcwoKZGVmIGdldF92YWx1ZSh2YXJpYWJsZSxkZWZhdWx0KToKCWlmIG5vdCB2YXJpYWJsZToKCQlyZXR1cm4gZGVmYXVsdAoJZWxzZToKCQlyZXR1cm4gdmFyaWFibGUKCmRlZiBnZXRfcm9vdF9kaXJlY3RvcnkoY2xhc3NfbmFtZSxyb290X3ZhcmlhYmxlPU5vbmUsZGVmYXVsdF92YWx1ZT1Ob25lKToKICAgIHJvb3RfdmFyaWFibGU9Z2V0X3ZhbHVlKHJvb3RfdmFyaWFibGUsZiJ7Y2xhc3NfbmFtZS51cHBlcigpfV9ST09UIikKICAgIGRlZmF1bHRfdmFsdWU9Z2V0X3ZhbHVlKGRlZmF1bHRfdmFsdWUsZiJ7b3MuZW52aXJvblsnSE9NRSddfS97Y2xhc3NfbmFtZS50aXRsZSgpfXMiKQogICAgcmV0dXJuIG9zLnBhdGguZXhwYW5kdXNlcihvcy5nZXRlbnYocm9vdF92YXJpYWJsZSxkZWZhdWx0X3ZhbHVlKSkKCmZvciB2YXIgaW4gWyJST09UIiwgIk5BTUVTIiwiVEVNUERJUiIsIkdMT0JBTFMiXToKICAgIGdsb2JhbHMoKVt2YXJdPU5vbmUgIAogICAgCiNST09UPU5vbmUKI05BTUVTPU5vbmUKI0ZMQUdTPU5vbmUKI0ZVTkNUSU9OPU5vbmUKI1RFTVBESVI9Tm9uZQoKZGVmIGxpc3RfaXRlbXNfaW5fcm9vdChuYW1lcyxmbGFncyxjbGFzc19uYW1lKToKICAgIEFsbD1bXyBmb3IgXyBpbiBzb3J0ZWQob3MubGlzdGRpcihST09UKSkgaWYgbm90IF8uc3RhcnRzd2l0aCgnLicpIF0KICAgIAogICAgZm9yIGZsYWcgaW4gWyJzdGFydGVkIiwic3RvcHBlZCIsImVuYWJsZWQiLCJkaXNhYmxlZCJdOgogICAgICAgIGlmICItLSIrZmxhZyBpbiBmbGFnczoKICAgICAgICAgICAgbmFtZXMrPVtfIGZvciBfIGluIEFsbCBpZiBmbGFnLnRpdGxlKCkgaW4gZXZhbChmIntjbGFzc19uYW1lfShfKS5TdGF0dXMoKSIsR0xPQkFMUyxsb2NhbHMoKSkgXQogICAgICAgICAgICBmbGFncy5yZW1vdmUoIi0tIitmbGFnKQoKICAgIGlmICItLWFsbCIgaW4gZmxhZ3M6CiAgICAgICAgbmFtZXMrPUFsbAogICAgICAgIGZsYWdzLnJlbW92ZSgiLS1hbGwiKQogICAgaWYgbmFtZXM9PVtdOgogICAgICAgIHByaW50KGYiTm8ge2NsYXNzX25hbWV9cyBzcGVjaWZpZWQhIikKICAgICAgICBleGl0KCkKICAgIHJldHVybiBuYW1lcwoKZGVmIGZsYXR0ZW5fbGlzdChpdGVtcyk6CiAgICAiIiJZaWVsZCBpdGVtcyBmcm9tIGFueSBuZXN0ZWQgaXRlcmFibGUuIiIiCiAgICBmb3IgeCBpbiBpdGVtczoKICAgICAgICBpZiBpc2luc3RhbmNlKHgsIHR5cGluZy5JdGVyYWJsZSkgYW5kIG5vdCBpc2luc3RhbmNlKHgsIChzdHIsIGJ5dGVzKSk6CiAgICAgICAgICAgIGZvciBzdWJfeCBpbiBmbGF0dGVuX2xpc3QoeCk6CiAgICAgICAgICAgICAgICB5aWVsZCBzdWJfeAogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHlpZWxkIHgKCmRlZiBwcmludF9saXN0KGwpOgogICAgZm9yIGVsZW1lbnQgaW4gbDoKICAgICAgICBpZiBlbGVtZW50IGlzIE5vbmU6CiAgICAgICAgICAgIHByaW50KGVuZD0nJykKICAgICAgICBlbHNlOgogICAgICAgICAgICBwcmludChlbGVtZW50KQoKZGVmIHNwbGl0X3N0cmluZ19ieV9jaGFyKHN0cmluZyxjaGFyPSc6Jyk6CiAgICBQQVRURVJOID0gcmUuY29tcGlsZShyZicnJygoPzpbXlx7Y2hhcn0iJ118IlteIl0qInwnW14nXSonKSspJycnKQogICAgcmV0dXJuIFtfIGZvciBfIGluIGxpc3QoUEFUVEVSTi5zcGxpdChzdHJpbmcpKSBpZiBfIG5vdCBpbiBbJycsIGNoYXJdXQoKCmRlZiBzaGVsbF9jb21tYW5kKGNvbW1hbmQsc3Rkb3V0PXN1YnByb2Nlc3MuUElQRSxzdGRlcnI9c3VicHJvY2Vzcy5TVERPVVQsYXJiaXRyYXJ5PUZhbHNlLGJsb2NrPVRydWUsZW52PU5vbmUpOgogICAgcHJvY2VzcyA9IHN1YnByb2Nlc3MuUG9wZW4oY29tbWFuZCwgc3Rkb3V0PXN0ZG91dCwgc3RkZXJyPXN0ZGVycix1bml2ZXJzYWxfbmV3bGluZXM9VHJ1ZSxzaGVsbD1hcmJpdHJhcnksZW52PWVudikKICAgIGlmIGJsb2NrOgogICAgICAgIHJldHVybiBwcm9jZXNzLmNvbW11bmljYXRlKClbMF0KCmRlZiB3YWl0X3VudGlsX3BpZF9leGl0cyhwaWQpOgogICAgCiAgICBkZWYgcGlkX2V4aXN0cyhwaWQpOiAgIAogICAgICAgICIiIiBDaGVjayBGb3IgdGhlIGV4aXN0ZW5jZSBvZiBhIHVuaXggcGlkLiAiIiIKICAgICAgICB0cnk6CiAgICAgICAgICAgIG9zLmtpbGwocGlkLCAwKQogICAgICAgIGV4Y2VwdCBPU0Vycm9yOgogICAgICAgICAgICByZXR1cm4gRmFsc2UKICAgICAgICBlbHNlOgogICAgICAgICAgICByZXR1cm4gVHJ1ZQogICAgICAgICAgICAKICAgIHdoaWxlIHBpZF9leGlzdHMocGlkKToKICAgICAgICB0aW1lLnNsZWVwKDAuMjUpCmRlZiBraWxsX3Byb2Nlc3NfZ3JhY2VmdWxseShwaWQpOgogICAgCiAgICB0cnk6CiAgICAgICAgb3Mua2lsbChwaWQsc2lnbmFsLlNJR1RFUk0pCiAgICAgICAgd2FpdF91bnRpbF9waWRfZXhpdHMocGlkKQogICAgZXhjZXB0IFByb2Nlc3NMb29rdXBFcnJvcjoKICAgICAgICBwYXNzCiAgICAKZGVmIGV4dHJhY3RfYXJndW1lbnRzKCk6CiAgICBhcmd1bWVudHM9c3lzLmFyZ3ZbMTpdCiAgICB0cnk6CiAgICAgICAgRlVOQ1RJT049YXJndW1lbnRzWzBdCiAgICBleGNlcHQgSW5kZXhFcnJvcjoKICAgICAgICBwcmludCgiTm8gZnVuY3Rpb24gc3BlY2lmaWVkISIpCiAgICAgICAgZXhpdCgpCiAgICBhcmd1bWVudHM9YXJndW1lbnRzWzE6XQogICAgCiAgICBOQU1FUz1bXQogICAgRkxBR1M9YXJndW1lbnRzCiAgICBmb3IgaSBpbiByYW5nZShsZW4oYXJndW1lbnRzKSk6CiAgICAgICAgaWYgbm90IGFyZ3VtZW50c1tpXS5zdGFydHN3aXRoKCItLSIpOgogICAgICAgICAgICBGTEFHUz1hcmd1bWVudHNbOmldCiAgICAgICAgICAgIE5BTUVTPWFyZ3VtZW50c1tpOl0KICAgICAgICAgICAgYnJlYWsKICAgIHJldHVybiAoTkFNRVMsRkxBR1MsRlVOQ1RJT04pCgpkZWYgYWRkX2Vudmlyb25tZW50X3ZhcmlhYmxlX3RvX3N0cmluZyhzdHJpbmcsZW52X3Zhcik6CiAgICByZXR1cm4gc3RyaW5nK2YiOyBleHBvcnQge2Vudl92YXJ9IgoKZGVmIHdhaXQoZGVsYXk9Tm9uZSk6CiAgICB0aHJlYWRpbmcuRXZlbnQoKS53YWl0KHRpbWVvdXQ9ZGVsYXkpCgpkZWYgZXhlY3V0ZV9jbGFzc19tZXRob2QoY2xhc3NfaW5zdGFuY2UsZnVuY3Rpb24pOgogICAgaWYgbm90IGNhbGxhYmxlKGdldGF0dHIoY2xhc3NfaW5zdGFuY2UsIGZ1bmN0aW9uLnRpdGxlKCksTm9uZSkpOgogICAgICAgICAgICBwcmludChmIkNvbW1hbmQge2Z1bmN0aW9ufSBkb2Vzbid0IGV4aXN0ISIpCiAgICAgICAgICAgIGV4aXQoKQogICAgZWxzZToKICAgICAgICByZXR1cm4gbGlzdChmbGF0dGVuX2xpc3QoW2dldGF0dHIoY2xhc3NfaW5zdGFuY2UsZnVuY3Rpb24udGl0bGUoKSkoKV0pKQoKZGVmIGNoZWNrX2lmX2VsZW1lbnRfYW55X2lzX2luX2xpc3QoZWxlbWVudHMsX2xpc3QpOgogICAgcmV0dXJuIGFueShfIGluIF9saXN0IGZvciBfIGluIGVsZW1lbnRzKQogICAgCmRlZiBleHBvcnRfbWV0aG9kc19nbG9iYWxseShjbGFzc19uYW1lKToKICAgIGZvciBmdW5jIGluIFtmdW5jIGZvciBmdW5jIGluIGRpcihldmFsKGNsYXNzX25hbWUsR0xPQkFMUykpIGlmIGNhbGxhYmxlKGdldGF0dHIoZXZhbChjbGFzc19uYW1lLEdMT0JBTFMpLCBmdW5jKSkgYW5kIG5vdCBmdW5jLnN0YXJ0c3dpdGgoJ19fJyldOgogICAgICAgIGV4ZWMoZiJnbG9iYWwge2Z1bmN9IixHTE9CQUxTKQogICAgICAgIGV4ZWMoZiJ7ZnVuY30gPSB7Y2xhc3NfbmFtZS5sb3dlcigpfS57ZnVuY30iLEdMT0JBTFMpCgpkZWYgd3JhcF9hbGxfbWV0aG9kc19pbl9jbGFzc193aXRoX2NoZGlyX2NvbnRleHRtYW5hZ2VyKHNlbGYscGF0aCk6CiAgICBAY29udGV4dGxpYi5jb250ZXh0bWFuYWdlcgogICAgZGVmIHNldF9kaXJlY3RvcnkocGF0aCk6CiAgICAgICAgIiIiU2V0cyB0aGUgY3dkIHdpdGhpbiB0aGUgY29udGV4dAogICAgCiAgICAgICAgQXJnczoKICAgICAgICAgICAgcGF0aCAoUGF0aCk6IFRoZSBwYXRoIHRvIHRoZSBjd2QKICAgIAogICAgICAgIFlpZWxkczoKICAgICAgICAgICAgTm9uZQogICAgICAgICIiIgogICAgCiAgICAgICAgb3JpZ2luID0gb3MucGF0aC5hYnNwYXRoKG9zLmdldGN3ZCgpKQogICAgICAgIHRyeToKICAgICAgICAgICAgb3MuY2hkaXIocGF0aCkKICAgICAgICAgICAgeWllbGQKICAgICAgICBmaW5hbGx5OgogICAgICAgICAgICAgICAgb3MuY2hkaXIob3JpZ2luKQogICAgCiAgICBkZWYgd3JhcHBlcihmdW5jKToKICAgICAgICBkZWYgbmV3X2Z1bmMoKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAgICAgd2l0aCBzZXRfZGlyZWN0b3J5KHBhdGgpOgogICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMoKmFyZ3MsICoqa3dhcmdzKQogICAgICAgIHJldHVybiBuZXdfZnVuYwogICAgICAgICAgICAKICAgIGZvciBmdW5jIGluIFtmdW5jIGZvciBmdW5jIGluIGRpcihzZWxmKSBpZiBjYWxsYWJsZShnZXRhdHRyKHNlbGYsIGZ1bmMpKSBhbmQgbm90IGZ1bmMuc3RhcnRzd2l0aCgnX18nKV06CiAgICAgICAgc2V0YXR0cihzZWxmLGZ1bmMsd3JhcHBlcihnZXRhdHRyKHNlbGYsZnVuYykpKQpjbGFzcyBDbGFzczoKICAgIGRlZiBfX2luaXRfXyhzZWxmLGNsYXNzX3NlbGYsY2xhc3NfbmFtZSk6CiAgICAgICAgc2VsZi5zZWxmPWNsYXNzX3NlbGYKICAgICAgICBzZWxmLm5hbWU9Y2xhc3NfbmFtZQogICAgCiAgICBkZWYgY2xhc3NfaW5pdChzZWxmLF9uYW1lLF9mbGFncyxfZnVuY3Rpb24sX3dvcmtkaXIpOgogICAgICAgIHNlbGYuc2VsZi5uYW1lPV9uYW1lCiAgICAgICAgCiAgICAgICAgc2VsZi5zZWxmLmZsYWdzPWdldF92YWx1ZShfZmxhZ3MsW10pCiAgICAgICAgCiAgICAgICAgc2VsZi5zZWxmLmZ1bmN0aW9uPWdldF92YWx1ZShfZnVuY3Rpb24sIiIpCiAgICAgICAgCiAgICAgICAgaWYgc2VsZi5zZWxmLmZ1bmN0aW9uIG5vdCBpbiBbImluaXQiXToKICAgICAgICAgICAgaWYgbm90IG9zLnBhdGguaXNkaXIoZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfSIpOgogICAgICAgICAgICAgICAgIHJhaXNlIERvZXNOb3RFeGlzdCgpCiAgICAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgIHdyYXBfYWxsX21ldGhvZHNfaW5fY2xhc3Nfd2l0aF9jaGRpcl9jb250ZXh0bWFuYWdlcihzZWxmLnNlbGYsZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfSIpCiAgICAgICAgc2VsZi5zZWxmLndvcmtkaXI9X3dvcmtkaXIKICAgICAgICAKICAgIGRlZiBzdG9wKHNlbGYpOgogICAgICAgIGlmICJTdG9wcGVkIiBpbiBzZWxmLnNlbGYuU3RhdHVzKCk6CiAgICAgICAgICAgIHJldHVybiBmIlNlcnZpY2Uge3NlbGYuc2VsZi5uYW1lfSBpcyBhbHJlYWR5IHN0b3BwZWQiCiAgICAgICAgCiAgICAgICAgZm9yIHBpZCBpbiBzZWxmLnNlbGYuUHMoIm1haW4iKToKICAgICAgICAgICAga2lsbF9wcm9jZXNzX2dyYWNlZnVsbHkocGlkKQogICAgICAgIAogICAgICAgIGZvciBlbmRpbmcgaW4gWyJsb2ciLCJsb2NrIl06CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgb3MucmVtb3ZlKGYie1RFTVBESVJ9L3tzZWxmLm5hbWV9X3tzZWxmLnNlbGYubmFtZX0ue2VuZGluZ30iKQogICAgICAgICAgICBleGNlcHQgRmlsZU5vdEZvdW5kRXJyb3I6CiAgICAgICAgICAgICAgICBwYXNzCgogICAgZGVmIHJlc3RhcnQoc2VsZik6CiAgICAgICAgcmV0dXJuIFtzZWxmLnNlbGYuU3RvcCgpLHNlbGYuc2VsZi5TdGFydCgpXQogICAgCiAgICBkZWYgZ2V0X21haW5fcHJvY2VzcyhzZWxmKToKICAgICAgICBpZiBub3Qgb3MucGF0aC5pc2ZpbGUoZiJ7VEVNUERJUn0ve3NlbGYubmFtZX1fe3NlbGYuc2VsZi5uYW1lfS5sb2NrIik6CiAgICAgICAgICAgICAgICByZXR1cm4gW10KICAgICAgICBlbHNlOgogICAgICAgICAgICByZXR1cm4gbGlzdChtYXAoaW50LFtfWzE6XSBmb3IgXyBpbiBzaGVsbF9jb21tYW5kKFsibHNvZiIsIi1GcCIsIi13IixmIntURU1QRElSfS97c2VsZi5uYW1lfV97c2VsZi5zZWxmLm5hbWV9LmxvY2siXSkuc3BsaXRsaW5lcygpXSkpCiAgICAKICAgIGRlZiBsaXN0KHNlbGYpOgogICAgICAgIHJldHVybiBzZWxmLnNlbGYubmFtZQogICAgICAgIAogICAgZGVmIHdvcmtkaXIoc2VsZix3b3JrX2Rpcik6CiAgICAgICAgI1JlbW92ZSB0cmFpbGluZyBzbGFzaGVzLCBidXQgb25seSBmb3Igc3RyaW5ncyB0aGF0IGFyZSBub3QgLwogICAgICAgIGlmIHdvcmtfZGlyLmVuZHN3aXRoKCcvJykgYW5kIGxlbih3b3JrX2Rpcik+MToKICAgICAgICAgICAgd29ya19kaXI9d29ya19kaXJbOi0xXQogICAgICAgICAgICAKICAgICAgICBpZiB3b3JrX2Rpci5zdGFydHN3aXRoKCIvIik6CiAgICAgICAgICAgIHNlbGYuc2VsZi53b3JrZGlyPXdvcmtfZGlyCiAgICAgICAgZWxzZTogICAgCiAgICAgICAgICAgIHNlbGYuc2VsZi53b3JrZGlyKz0nLycrd29ya19kaXIKICAgICAgICAKICAgICAgICAjUmVtb3ZlIHJlcGVhdGVkIC8gaW4gd29ya2RpcgogICAgICAgIHNlbGYuc2VsZi53b3JrZGlyPXJlLnN1YihyJygvKVwxKycsIHInXDEnLHNlbGYuc2VsZi53b3JrZGlyKQoKICAgIGRlZiBlZGl0KHNlbGYpOgogICAgICAgIGlmICJFbmFibGVkIiBpbiBzZWxmLnNlbGYuU3RhdHVzKCk6CiAgICAgICAgICAgIHNoZWxsX2NvbW1hbmQoW29zLmdldGVudigiRURJVE9SIiwidmkiKSxmIntST09UfS97c2VsZi5zZWxmLm5hbWV9L3tzZWxmLm5hbWV9LnB5Il0sc3Rkb3V0PU5vbmUpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgc2hlbGxfY29tbWFuZChbb3MuZ2V0ZW52KCJFRElUT1IiLCJ2aSIpLGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0vLntzZWxmLm5hbWV9LnB5Il0sc3Rkb3V0PU5vbmUpCgogICAgZGVmIHN0YXR1cyhzZWxmKToKICAgICAgICBzdGF0dXM9W10KICAgICAgICBpZiBvcy5wYXRoLmlzZmlsZShmIntURU1QRElSfS97c2VsZi5uYW1lfV97c2VsZi5zZWxmLm5hbWV9LmxvZyIpOgogICAgICAgICAgICBzdGF0dXMrPVsiU3RhcnRlZCJdCiAgICAgICAgZWxzZToKICAgICAgICAgICAgc3RhdHVzKz1bIlN0b3BwZWQiXQogICAgICAgIAogICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKGYie1JPT1R9L3tzZWxmLnNlbGYubmFtZX0ve3NlbGYubmFtZX0ucHkiKToKICAgICAgICAgICAgc3RhdHVzKz1bIkVuYWJsZWQiXQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHN0YXR1cys9WyJEaXNhYmxlZCJdCiAgICAgICAgcmV0dXJuIHN0YXR1cwogICAgCiAgICBkZWYgZW5hYmxlKHNlbGYpOgogICAgICAgIGlmICJFbmFibGVkIiBpbiBzZWxmLnNlbGYuU3RhdHVzKCk6CiAgICAgICAgICAgIHJldHVybiBbZiJ7c2VsZi5uYW1lfSBpcyBhbHJlYWR5IGVuYWJsZWQiXQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIG9zLnJlbmFtZShmIntST09UfS97c2VsZi5zZWxmLm5hbWV9Ly57c2VsZi5uYW1lfS5weSIsZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfS97c2VsZi5uYW1lfS5weSIpCiAgICAgICAgCiAgICAgICAgaWYgJy0tbm93JyBpbiBzZWxmLnNlbGYuZmxhZ3M6CiAgICAgICAgICAgIHJldHVybiBbc2VsZi5zZWxmLlN0YXJ0KCldCgogICAgZGVmIGxvb3Aoc2VsZixjb21tYW5kLGRlbGF5PTYwKToKICAgICAgICBpZiBpc2luc3RhbmNlKGNvbW1hbmQsc3RyKToKICAgICAgICAgICAgZGVmIGZ1bmMoKToKICAgICAgICAgICAgICAgIHdoaWxlIFRydWU6CiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxmLlJ1bihjb21tYW5kKQogICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZi5XYWl0KGRlbGF5KQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGRlZiBmdW5jKCk6CiAgICAgICAgICAgICAgICB3aGlsZSBUcnVlOiAgCiAgICAgICAgICAgICAgICAgICAgY29tbWFuZCgpCiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxmLldhaXQoZGVsYXkpCiAgICAgICAgc2VsZi5zZWxmLlJ1bigiIikgI05lZWRlZCB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnMgd2l0aCBhIHJhY2UgdGhhdCdzIHJpZ2h0IGFmdGVyIC0tLSBqdXN0IHJ1biBzZWxmLnNlbGYuUnVuIG9uY2UKICAgICAgICB0aHJlYWRpbmcuVGhyZWFkKHRhcmdldD1mdW5jLGRhZW1vbj1UcnVlKS5zdGFydCgpCiAgICAgICAKICAgIGRlZiBkaXNhYmxlKHNlbGYpOgogICAgICAgIGlmICJEaXNhYmxlZCIgaW4gc2VsZi5zZWxmLlN0YXR1cygpOgogICAgICAgICAgICByZXR1cm4gW2Yie3NlbGYuc2VsZi5uYW1lfSBpcyBhbHJlYWR5IGRpc2FibGVkIl0KICAgICAgICBlbHNlOgogICAgICAgICAgICBvcy5yZW5hbWUoZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfS97c2VsZi5uYW1lfS5weSIsZiJ7Uk9PVH0ve3NlbGYuc2VsZi5uYW1lfS8ue3NlbGYubmFtZX0ucHkiKQogICAgICAgIAogICAgICAgIGlmICctLW5vdycgaW4gc2VsZi5zZWxmLmZsYWdzOgogICAgICAgICAgICByZXR1cm4gW3NlbGYuc2VsZi5TdG9wKCldCgogICAgZGVmIGxvZyhzZWxmKToKICAgICAgICBzaGVsbF9jb21tYW5kKFsibGVzcyIsIitHIiwiLWYiLCItciIsZiJ7VEVNUERJUn0ve3NlbGYubmFtZX1fe3NlbGYuc2VsZi5uYW1lfS5sb2ciXSxzdGRvdXQ9Tm9uZSkKICAgIAogICAgZGVmIGRlbGV0ZShzZWxmKToKICAgICAgICBzZWxmLnNlbGYuU3RvcCgpCiAgICAgICAgc2h1dGlsLnJtdHJlZShmIntST09UfS97c2VsZi5zZWxmLm5hbWV9IikKICAgIAogICAgZGVmIHdhdGNoKHNlbGYpOgogICAgICAgIHNoZWxsX2NvbW1hbmQoWyJ0YWlsIiwiLWYiLCItLWZvbGxvdz1uYW1lIixmIntURU1QRElSfS97c2VsZi5uYW1lfV97c2VsZi5zZWxmLm5hbWV9LmxvZyJdLHN0ZG91dD1Ob25lKQogICAgCgo=').decode("utf-8"),utils_module.__dict__)
sys.modules["utils"]=utils_module

import utils
CLASS_NAME="Container"

utils.ROOT=ROOT=utils.get_root_directory(CLASS_NAME)
utils.TEMPDIR=TEMPDIR=utils.get_tempdir()

NAMES,FLAGS,FUNCTION=utils.extract_arguments()

utils.NAMES=NAMES
utils.ROOT=ROOT
utils.GLOBALS=globals()

SHELL_CWD=os.environ.get("PWD")
PATH="PATH=/bin:/usr/sbin:/sbin:/usr/bin"

#Helper functions
def list_containers(*args, **kwargs):
    return utils.list_items_in_root(*args, FLAGS,CLASS_NAME,**kwargs)    

def flatten(*args, **kwargs):
    return utils.flatten_list(*args, **kwargs)

def print_result(*args, **kwargs):
    return utils.print_list(*args, **kwargs)

def convert_colon_string_to_directory(string):
    string=utils.split_string_by_char(string,char=":")
    if string[0]=="root":
        string=string[1] #The directory is just the absolute path in the host
    elif len(string)==1:
        string=string[0] # No container was specified, so assume "root"
    else:
        string=f"{ROOT}/{string[0]}/diff{string[1]}" # Container was specified, so use it
    string=os.path.expanduser(string)
    return string
    
def load_dependencies(layer):
    with open(f"{ROOT}/{layer}/container-compose.py") as fh:        
       root = ast.parse(fh.read())
       for node in ast.iter_child_nodes(root):
           if isinstance(node, ast.Expr) and isinstance(node.value,ast.Call):
               function=node.value.func.id
               if function in ["Layer","Base","Env","Shell"]:
                   arguments=[eval(ast.unparse(val)) for val in node.value.args]
                   globals()[function](*arguments)

def remove_empty_folders_in_diff():
    walk = list(os.walk("diff"))
    for path, _, _ in walk[::-1]:
        if not path.startswith("diff/.unionfs"):
            if len(os.listdir(path)) == 0:
                os.rmdir(path)
                
ContainerDoesNotExist=utils.DoesNotExist
class Container:
    def __init__(self,_name,_flags=None,_unionopts=None,_workdir='/',_env=None,_function=None,_uid=None,_gid=None,_shell=None):
        self.Class = utils.Class(self,CLASS_NAME.lower())
        self.Class.class_init(_name,_flags,_function,_workdir)
        
        self.base="void"
        
        self.unionopts=utils.get_value(_unionopts,"diff=RW")
        
        self.env=utils.get_value(_env,f"export {PATH}")
        
        #Whether we mounted dev, proc, etc.
        self.mounted_special=False
            
        self.workdir=_workdir
        
        self.uid=utils.get_value(_uid,os.getuid())
        self.gid=utils.get_value(_gid,os.getgid())
        
        self.shell=utils.get_value(_shell,"/bin/bash")
        
        self.temp_layers=[]
        
        self.hardlinks=[]
    
    #Functions
    def Run(self,command="",pipe=False):
        if self.function=="build":
            if command.strip()!="":
                print(f"Command: {command}")
        self.Base(self.base)
        #Only mount if this is the first Run called, where the base hasn't been added to unionopts
        if not self.unionopts.endswith(f":{ROOT}/{self.base}/diff=RO"):
            self.unionopts+=f":{ROOT}/{self.base}/diff=RO"
            
            #Prevent merged from being mounted multiple times
            if not os.path.ismount("merged"):
                utils.shell_command(["unionfs","-o","allow_other,cow,hide_meta_files",f"{self.unionopts}","merged"])
               
        #Mount dev,proc, etc. over the unionfs to deal with mmap bugs (fuse may be patched to deal with this natively so I can just mount on the diff directory, but for now, this is what is needed)
        if not self.mounted_special:
            for dir in ["dev","proc","sys","run"]:
                if not os.path.ismount(f"merged/{dir}"):
                    #Use bind mounts for special mounts, as bindfs has too many quirks (and I'm using sudo regardless)
                    if sys.platform=="darwin":
                        #MacOS doesn't have bind-mounts, and direct_io doesn't affect them
                        utils.shell_command(["sudo", "bindfs", "-o", "direct_io,allow_other,dev", f"/{dir}", f"merged/{dir}"])
                    elif sys.platform=="cygwin":
                        #Cygwin doesn't have rbind
                        utils.shell_command(["sudo","mount","-o","bind",f"/{dir}",f"merged/{dir}"])
                    else:
                        utils.shell_command(["sudo","mount","--rbind",f"/{dir}",f"merged/{dir}"])
                   
            self.mounted_special=True
            
        with open(f"{TEMPDIR}/container_{self.name}.log","a+") as log_file:
            log_file.write(f"Command: {command}\n")
            log_file.flush()
            
            #Pipe output to variable
            if pipe:
                stdout=subprocess.PIPE
                stderr=subprocess.DEVNULL
            #Print output to file
            else:
                stdout=log_file
                stderr=subprocess.STDOUT
            return utils.shell_command(["sudo","nohup","chroot",f"--userspec={self.uid}:{self.gid}", "merged",f"{self.shell}","-c",f"{self.env}; cd {self.workdir}; {command}"],stdout=stdout,stderr=stderr)
            
    
    def Ps(self,process=None):
        if process=="main" or ("--main" in self.flags):
            return self.Class.get_main_process()
        elif process=="auxiliary" or ("--auxiliary" in self.flags):
            if not os.path.isdir("merged"):
                return []
            processes=[_[1:] for _ in utils.shell_command(["lsof","-Fp","-w","--","merged"]).splitlines()]
            return list(map(int,processes))
    
    def Mount(self,IN,OUT):
        try:
            os.makedirs(f"diff{OUT}",exist_ok=True)
        except FileExistsError:
            os.remove(f"diff{OUT}")
            os.makedirs(f"diff{OUT}",exist_ok=True)
        if not os.path.ismount(f"diff{OUT}"):
            IN=convert_colon_string_to_directory(IN)
            utils.shell_command(["bindfs",IN,f"diff{OUT}"])
    
    def Copy(self,src,dest):
        #Relative directory
        if not dest.startswith("/"):
            dest=f"diff{self.workdir}/{dest}"
        
        #Absolute directory
        else:
            dest=f"diff{dest}"
        
        src=convert_colon_string_to_directory(src)
        #Relative directory
        if not src.startswith("/"):
            src=f"{SHELL_CWD}/{src}"
            
        #Remove trailing slashes, in order to prevent gotchas with cp
        if src.endswith("/"):
            src=src[:-1]
        if dest.endswith("/"):
            dest=dest[:-1]
        
        #print(f"cp -a {src} {dest}")                   
        cp_error=utils.shell_command(["cp","-a",f"{src}",f"{dest}"])
        if "cp: cannot create" in cp_error:
            #dest does not exist, so create its parent's folder
            os.makedirs(os.path.dirname(dest),exist_ok=True)
            utils.shell_command(["cp","-a",f"{src}",f"{dest}"])

    def Loop(self,*args, **kwargs):
        self.Class.loop(*args, **kwargs)
        #Run(f'(while true; do "{command}"; sleep {delay}; done)')
        
    def Base(self,base):
        
        #Effectively make subsequent Bases a no-op
        if not self.unionopts.endswith(f":{ROOT}/{self.base}/diff=RO"):
            self.base=base
        load_dependencies(base)
    def Wait(self,*args, **kwargs):
        utils.wait(*args, **kwargs)

    def Layer(self,layer,mode="RO"):
        if self.function=="build":
            if len(os.listdir(f"{ROOT}/{layer}/diff"))<2:
                utils.shell_command(["container","build",layer]) #Build layer if it doesn't exist
                self.temp_layers.append(layer) #Layer wasn't needed before so we can delete it after
        load_dependencies(layer)
        self.unionopts+=f":{ROOT}/{layer}/diff={mode}"
    
    def Workdir(self,*args, **kwargs):
        self.Class.workdir(*args, **kwargs)
        os.makedirs(f"diff{self.workdir}",exist_ok=True)
        self.Update("workdir")
    
    def Env(self,*args, **kwargs):
        self.env=utils.add_environment_variable_to_string(self.env,*args, **kwargs)
        self.Update("env")
    
    def User(self,user=""):
        if user=="":
            self.uid=os.getuid()
            self.gid=os.getgid()
        else:
            user=utils.split_string_by_char(user,char=":")
            if len(user)==1:
                user.append(user[0]) #Make group the same as user if it is not available
            if user[0].isnumeric():
                self.uid=user[0]
            else:
                self.uid=int(self.Run(f"id -u {user[0]}",pipe=True))
                #self.uid=pwd.getpwnam(user[0])[2]
            
            if user[1].isnumeric():
                self.gid=user[1]
            else:
                self.gid=int(self.Run(f"id -g {user[1]}",pipe=True))
                #self.gid=pwd.getpwnam(user[1])[2]
        self.Update(["uid","gid"])
    
    def Shell(self,shell):
        self.shell=shell
        self.Update("shell")        
    
    def Volume(self,name,path):
        name=utils.split_string_by_char(name,char=":")
        
        #Allow to use volumes from other containers
        if len(name)==1:
            name.insert(0,self.name)
        volume_path=f"{ROOT}/{name[0]}/Volumes/{name[1]}"
        
        #If a directory, just mount it directly. If file, hardlink it
        if os.path.isdir(volume_path):
            self.Mount(volume_path,path)
        else:
            try:
                os.link(volume_path,f"diff/{path}")
            except FileExistsError:
                os.remove(f"diff/{path}")
                os.link(volume_path,f"diff/{path}")
            self.hardlinks.append(f"diff/{path}")
        
    def Update(self,keys):
        if self.function=="build":
            return #No lock file when building --- no need for it
        if isinstance(keys,str):
            keys=[keys]
        
        with open(f"{TEMPDIR}/container_{self.name}.lock","r") as f:
            data=json.load(f)
            
        for key in keys:
            data[key]=getattr(self,key)
        
        with open(f"{TEMPDIR}/container_{self.name}.lock","w+") as f:
            json.dump(data,f)  
        
    #Commands      
    def Start(self):
        if "Started" in self.Status():
            return f"Container {self.name} is already started"
        
        #Fork process, so it can run in the background
        pid=os.fork()
        
        #If child, run code, then exit 
        if pid==0:
            self.Base(self.base)
            with open(f"{TEMPDIR}/container_{self.name}.log","a+") as f:
                pass
            #Open a lock file so I can find it with lsof later
            self.lock=open(f"{TEMPDIR}/container_{self.name}.lock","w+")
            
            with open(f"{TEMPDIR}/container_{self.name}.lock","w+") as f:
                json.dump({},f)
            
            self.Update(["env","workdir", "uid","gid","shell"])
            
            
            def on_Stop(a,b):
                for pid in self.Ps("auxiliary"):
                    utils.kill_process_gracefully(pid)
                
                #Unmount dev,proc, etc. if directory exists
                if os.path.isdir("merged"):
                    for dir in os.listdir("merged"):
                        if os.path.ismount(f"merged/{dir}"):
                        
                            utils.shell_command(["sudo","mount","--make-rslave",f"merged/{dir}"])
                            utils.shell_command(["sudo","umount","-R","-l",f"merged/{dir}"])
                            
                
                diff_directories=[utils.split_string_by_char(_," ")[2] for _ in utils.shell_command(["mount"]).splitlines() if f"{ROOT}/{self.name}/diff" in _]
                for dir in diff_directories:
                     utils.shell_command(["umount","-l",dir])
                     utils.shell_command(["rm","-rf",dir])
                utils.shell_command(["umount","-l","merged"])
            
                
                for hardlink in self.hardlinks:
                    os.remove(hardlink) #Remove volume hardlinks when done
                exit()
            signal.signal(signal.SIGTERM,on_Stop)
            #Run *service.py
            with open(f"{ROOT}/{self.name}/container-compose.py") as f:
                code=f.read()
            exec(code,globals(),locals())
            
            #Don't have to put Run() in container-compose.py just to start it
            self.Run()
            self.Wait()
            exit()
        
    def Build(self):
        self.Stop()
        with open("Containerfile.py") as f:
         code = compile(f.read(), 'Containerfile.py', 'exec')
         exec(code,globals(),locals())
        self.Stop()
        remove_empty_folders_in_diff()
        for layer in self.temp_layers:
            utils.shell_command(["container","clean",layer]) #Clean layer if it was temporary
        
       
    def Stop(self):
        return [self.Class.stop()]

    def Restart(self):
        return self.Class.restart()
    
    def Chroot(self):
        if "Stopped" in self.Status():
            return ["Can't chroot into stopped container!"]
        
        with open(f"{TEMPDIR}/container_{self.name}.lock","r") as f:
            data=json.load(f)
        
        command=None
        for flag in self.flags:
            if flag.startswith("--run="):
                command=flag.split("=",1)[1]
        
        if not command:
            command=""
        else:
            command=f"-c '{command}'"
        for key in data:
            setattr(self,key,data[key])
        utils.shell_command(["sudo","chroot",f"--userspec={self.uid}:{self.gid}",f"{ROOT}/{self.name}/merged","/bin/sh","-c",f"""{self.env}; cd {self.workdir}; {self.shell} {command}"""],stdout=None)
        
        #For some reason, only os.system doesn't use the PS1
        #os.system(f"sudo chroot --userspec={self.uid}:{self.gid} {ROOT}/{self.name}/merged /bin/sh -c '{self.env}; cd {self.workdir}; {self.shell}'")
        
        if "--and-stop" in self.flags:
            return [self.Stop()]
    
    
    def List(self):
        return self.Class.list()

    def Init(self):
       
        os.makedirs(f"{ROOT}/{self.name}",exist_ok=True)
        os.chdir(f"{ROOT}/{self.name}")
        os.makedirs("diff",exist_ok=True)
        os.makedirs("merged",exist_ok=True)
        
        if '--temp' in self.flags:
            self.flags.append('--no-edit')
            self.flags.append('--only-chroot')
        with open(f"container-compose.py",'a'):
            pass
        
        if '--build' in self.flags:
            with open(f"Containerfile",'a'):
                pass
        
        if '--no-edit' not in self.flags:
            self.Edit()
        
        if utils.check_if_element_any_is_in_list(['--only-chroot','--and-chroot'],self.flags):
            return [self.Start(),self.Delete() if '--temp' in self.flags else None]

    def Edit(self):
        if '--build' in self.flags:
            utils.shell_command([os.getenv("EDITOR","vi"),f"{ROOT}/{self.name}/Containerfile.py"],stdout=None)
        else:
            utils.shell_command([os.getenv("EDITOR","vi"),f"{ROOT}/{self.name}/container-compose.py"],stdout=None)

    def Status(self):
        return self.Class.status()

    def Log(self):
        self.Class.log()
    
    def Clean(self):
        self.Stop()
        os.system(f"sudo rm -rf diff/*")
    
    def Delete(self):
        self.Stop()
        utils.shell_command(["sudo","rm","-rf",f"{ROOT}/{self.name}"])
    
    def Watch(self):
        self.Class.watch()

NAMES=list_containers(utils.NAMES)
for name in NAMES:
    
    BASE="void"
    UNIONOPTS="diff=RW"
    
    try:
        container=Container(name,_flags=FLAGS,_unionopts=UNIONOPTS,_function=FUNCTION)
    except ContainerDoesNotExist:
        print(f"Container {name} does not exist")
        continue
        
    utils.export_methods_globally(CLASS_NAME)
    result=utils.execute_class_method(eval(f"{CLASS_NAME.lower()}"),FUNCTION)
    
    print_result(result)
        

    
