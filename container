#!/usr/bin/env python
import subprocess
import re
import sys
import os
import signal
import typing
import tempfile
import shutil
import urllib
import json
import tarfile
from pprint import pprint
import platform
import threading
import time

ROOT=os.path.expanduser(os.getenv("CONTAINER_ROOT","~/Containers"))

arguments=sys.argv[1:]

try:
    FUNCTION=arguments[0]
except IndexError:
    print("No function specified!")
    exit()
arguments=arguments[1:]

#Populate arguments if it is empty
#if arguments==[]:
#    arguments=['--all']

NAMES=[]
FLAGS=arguments
TEMPDIR=tempfile.gettempdir()
SHELL=os.getenv('SHELL','bash')
SHELL_CWD=os.environ.get("PWD")
PATH="PATH=/bin:/usr/sbin:/sbin:/usr/bin"

#Helper functions
def List(_names=None,_flags=None):
    
    if not _flags:
        flags=FLAGS
    else:
        flags=_flags
    
    if not _names:
        names=NAMES
    else:
        names=_names
    
    AllContainers=sorted(os.listdir(f"{ROOT}"))
    
    if "--started" in flags:
        names+=[_ for _ in AllContainers if "Started" in Container(_).Status() ]
    if "--stopped" in flags:
        names+=[_ for _ in AllContainers if "Stopped" in Container(_).Status() ]
    if "--all" in flags:
        names+=AllContainers
    
    return names
    
def flatten(items):
    """Yield items from any nested iterable; see Reference."""
    for x in items:
        if isinstance(x, typing.Iterable) and not isinstance(x, (str, bytes)):
            for sub_x in flatten(x):
                yield sub_x
        else:
            yield x

def print_result(result):
    for element in result:
        if element is None:
            print(end='')
        else:
            print(element)

def split_by_char(string,char=':'):
    PATTERN = re.compile(rf'''((?:[^\{char}"']|"[^"]*"|'[^']*')+)''')
    return [_ for _ in list(PATTERN.split(string)) if _ not in ['', char]]
    
def Shell(command,stdout=subprocess.PIPE,stderr=subprocess.STDOUT):
    process = subprocess.run(command, stdout=stdout, stderr=stderr,universal_newlines=True)
    if stdout==subprocess.PIPE:
        return process.stdout

class ContainerDoesNotExist(Exception):
    pass
    
class Container:
    def __init__(self,_name,_flags=None,_unionopts=None,_workdir='/',_env=None,_function=None):
        self.name=_name
        if not _flags:
            self.flags=FLAGS
        else:
            self.flags=_flags
            
        self.base="void"
        
        if not _unionopts:
            self.unionopts="diff=RW"
        else:
            self.unionopts=_unionopts
        
        if not _env:
            self.env=f"export {PATH}"
        else:
            self.env=_env
        #Whether we mounted dev, proc, etc.
        self.mounted_special=False
           
        if not _function:
            self.function=FUNCTION
        else:
            self.function=_function
            
        self.workdir=_workdir
        
        
        if self.function not in ["init","import"]:
            if not os.path.isdir(f"{ROOT}/{self.name}"):
                 raise ContainerDoesNotExist()
                 return
            os.chdir(f"{ROOT}/{self.name}")
    
    #Functions
    def Run(self,command=""):
        if self.function=="build":
            if command.strip()!="":
                print(f"Command: {command}")
        self.Base(self.base)
        #Only mount if this is the first Run called, where the base hasn't been added to unionopts
        if not self.unionopts.endswith(f":{ROOT}/{self.base}/diff=RO"):
            self.unionopts+=f":{ROOT}/{self.base}/diff=RO"
            
            #Prevent merged from being mounted multiple times
            if not os.path.ismount("merged"):
                Shell(["unionfs","-o","allow_other,cow,hide_meta_files",f"{self.unionopts}","merged"])
               
        #Mount dev,proc, etc. over the unionfs to deal with mmap bugs (fuse may be patched to deal with this natively, but for now, this is what is needed)
        if not self.mounted_special:
            for dir in ["dev","proc","sys","run"]:
                if not os.path.ismount(f"merged/{dir}"):
                    #Use bind mounts for special mounts, as bindfs has too many quirks (and I'm using sudo regardless)
                    #Shell(f"sudo bindfs -o direct_io,allow_other,dev /{dir} merged/{dir}")
                    Shell(["sudo","mount","--rbind",f"/{dir}",f"merged/{dir}"])
                   
            self.mounted_special=True
            
        #Print command to file
        with open(f"{TEMPDIR}/container_{self.name}.log","a+") as f:
            f.write(f"Command: {command}")
            Shell(["sudo","nohup","chroot",f"--userspec={os.getuid()}:{os.getgid()}", "merged",f"{SHELL}","-c",f"{self.env}; cd {self.workdir}; {command}"],stdout=f)
            
    
    def Ps(self,process="auxiliary"):
        if process=="main":
            command=["lsof","-Fp","-w",f"/tmp/container_{self.name}.lock"]
        elif process=="auxiliary":
            command=["lsof","-Fp","-w","--","merged"]
            
        if process=="main":
            if not os.path.isfile(f"{TEMPDIR}/container_{self.name}.lock"):
                return []

        if process=="auxiliary":
            if not os.path.isdir("merged"):
                return []
        processes=[_[1:] for _ in Shell(command).splitlines()]        
        return list(map(int,processes))
    
    def Mount(self,IN,OUT):
        arrIN = split_by_char(IN)
        
        os.makedirs(f"diff{OUT}",exist_ok=True)
        if not os.path.ismount(f"diff{OUT}"):
            if arrIN[0]=="root":
                IN=arrIN[1]
            elif len(arrIN)==1:
                IN=arrIN[0]
            else:
                IN=f"{ROOT}/{arrIN[0]}/diff{arrIN[1]}"
            IN=os.path.expanduser(IN)
            Shell(["bindfs",IN,f"diff{OUT}"])
    
    def Loop(self,command,delay=60):
        if isinstance(command,str):
            def func():
                while True:
                    Run(command)
                    time.sleep(delay)
        else:
            def func():
                while True:  
                    command()
                    time.sleep(delay)
        threading.Thread(target=func).start()
        #Run(f'(while true; do "{command}"; sleep {delay}; done)')
        
    def Base(self,base):
        
        #Effectively make subsequent Bases a no-op
        if not self.unionopts.endswith(f":{ROOT}/{self.base}/diff=RO"):
            self.base=base
            
    def Layer(self,layer,mode="RO"):
        self.unionopts+=f":{ROOT}/{layer}/diff={mode}"
    
    def Workdir(self,work_dir):
        
        #Remove trailing slashes, but only for strings that are not /
        if work_dir.endswith('/') and len(work_dir)>1:
            work_dir=work_dir[:-1]
            
        if work_dir.startswith("/"):
            self.workdir=work_dir
        else:    
            self.workdir+='/'+work_dir
        
        #Remove repeated / in workdir
        self.workdir=re.sub(r'(/)\1+', r'\1',self.workdir)
        os.makedirs(f"diff{self.workdir}",exist_ok=True)
    
    def Copy(self,src,dest):
        #Relative directory
        if not dest.startswith("/"):
            dest=f"diff{self.workdir}/{dest}"
        
        #Absolute directory
        else:
            dest=f"diff{dest}"
        
        #Relative directory
        if not src.startswith("/"):
            src=f"{SHELL_CWD}/{src}"
            
        #Remove trailing slashes, in order to prevent gotchas with cp
        if src.endswith("/"):
            src=src[:-1]
        if dest.endswith("/"):
            dest=dest[:-1]
        
        #print(f"cp -a {src} {dest}")                   
        cp_error=Shell(["cp","-a",f"{src}",f"{dest}"])
        if "cp: cannot create" in cp_error:
            #dest does not exist, so create its parent's folder
            os.makedirs(os.path.dirname(dest),exist_ok=True)
            Shell(["cp","-a",f"{src}",f"{dest}"])
    
    def Env(self,env):
        self.env+=f"; export {env}"
        
    #Commands      
    def Start(self):
        
        self.Base(self.base)
        
        if self.Status()=="Started":
            return f"Container {self.name} is already started"
        
        #Fork process, so it can run in the background
        pid=os.fork()
        
        #If child, run code, then exit 
        if pid==0:
            #Open a lock file so I can find it with lsof later
            lock_file=open(f"{TEMPDIR}/container_{self.name}.lock","w+")
            #Run *service.py
            with open(f"{ROOT}/{self.name}/container-compose.py") as f:
                code=f.read()
            exec(code,globals(),locals())
            
            #Don't have to put Run() in container-compose.py just to start it
            self.Run()
            signal.pause()
            exit()
        if "--only-chroot" in self.flags:
            return [self.Chroot(), self.Stop()]
        elif "--and-chroot" in self.flags:
            return [self.Chroot()]
        
    def Build(self):
        self.Stop()
        with open("Containerfile") as f:
         code = compile(f.read(), 'Containerfile', 'exec')
         exec(code,globals(),locals())
        self.Stop()
       
    def Stop(self):
        if self.Status()=="Stopped":
            if self.name!=self.base:
                return f"Container {self.name} is already stopped"
       
        #Get PID of main Start process
        for pid in self.Ps("main"):
            os.kill(pid,signal.SIGTERM)
            try:
                os.waitpid(pid,0)
            except:
                pass

        #Kill all files under container
        for pid in self.Ps("auxiliary"):
            try:
                os.kill(pid,signal.SIGKILL)
                try:
                    os.waitpid(pid,0)
                except:
                    pass

            except ProcessLookupError:
                pass

        
        #Unmount dev,proc, etc. if directory exists
        if os.path.isdir("merged"):
            for dir in os.listdir("merged"):
                if os.path.ismount(f"merged/{dir}"):
                
                    Shell(["sudo","mount","--make-rslave",f"merged/{dir}"])
                    Shell(["sudo","umount","-R","-l",f"merged/{dir}"])
                    
        
        diff_directories=[split_by_char(_," ")[2] for _ in Shell(["mount"]).splitlines() if f"{ROOT}/{self.name}/diff" in _]
        for dir in diff_directories:
             Shell(["umount","-l",f"{dir}"])
        Shell(["umount","-l","merged"])
        try:
           os.remove(f"{TEMPDIR}/container_{self.name}.log")
        except FileNotFoundError:
            pass
        
        try:
           os.remove(f"{TEMPDIR}/container_{self.name}.lock")
        except FileNotFoundError:
            pass

    def Restart(self):
        return [self.Stop(),self.Start()]
    
    def Chroot(self):
        if self.flags==[] and ("Stopped" in self.Status()):
            self.flags+=['--only-chroot']
            return [self.Start()]
        os.system(f" {self.env}; sudo chroot --userspec=$(id -u):$(id -g) {ROOT}/{self.name}/merged {SHELL}")
    
    
    def List(self):
        return self.name

    def Init(self):
       
        os.makedirs(f"{ROOT}/{self.name}",exist_ok=True)
        os.chdir(f"{ROOT}/{self.name}")
        os.makedirs("diff",exist_ok=True)
        os.makedirs("merged",exist_ok=True)
        with open(f"container-compose.py",'a'):
            pass
        
        if '--build' in self.flags:
            with open(f"Containerfile",'a'):
                pass
        
        if '--no-edit' not in self.flags:
            self.Edit()
        
        if '--and-chroot' in self.flags:
            return [Container(self.name,self.flags+['--only-chroot'],self.unionopts).Start()]

    def Edit(self):
        if '--build' in self.flags:
            os.system(f"$EDITOR {ROOT}/{self.name}/Containerfile")
        else:
            os.system(f"$EDITOR {ROOT}/{self.name}/container-compose.py")

    def Status(self):
        if os.path.isfile(f"{TEMPDIR}/container_{self.name}.log"):
            return "Started"
        else:
            return "Stopped"

    def Log(self):
        Shell(["less","+G",f"{TEMPDIR}/container_{self.name}.log"],stdout=None)
    
    def Clean(self):
        self.Stop()
        os.system(f"sudo rm -rf diff/*")
    
    def Delete(self):
        self.Stop()
        Shell(["sudo","rm","-rf",f"{ROOT}/{self.name}"])
    
    def Watch(self):
        Shell(["tail","-f",f"{TEMPDIR}/container_{self.name}.log"],stdout=None)


   #Initializing some important things
#Flags go before the actual container names
for i in range(len(arguments)):
    if not arguments[i].startswith("--"):
        FLAGS=arguments[:i]
        NAMES=arguments[i:]
        break

#Special functions -- they don't follow any normal rules
def Import(_image=None,_container=None):
    
    image=_image
    container=_container
    
    if not image:
        image=NAME[0]
    if not container:
        container=NAME[1]
        
    #Make temp folder
    temp_folder=tempfile.mkdtemp()
    
    #What registry is being used
    registry=''
    
    if 'hub.docker.com/' in image:
        registry='docker'
    elif 'quay.io/' in image:
        registry='quay'
    else:
        registry='docker'
    
    #Convert urls into a proper format:
    
    #If there's more than one /, then this is a url, and have to be extracted properly
    if image.count('/') >1:
        #There's no https, we should fix that
        if urllib.parse.urlparse(image).netloc=='':
            image='https://' + image
    
        image=urllib.parse.urlparse(image).path
    
    if image.startswith('/'):
        image=image[1:]
    
    image = split_by_char(image)
    
    #Support Docker official images
    if registry=='docker':
        if '/' not in image[0]:
            image[0]='library/'+image[0]
        
    if len(image)==1:
        image.append('latest')
        
    #Get token
    
    if registry=='docker':
        token=urllib.request.urlopen(f"https://auth.docker.io/token?service=registry.docker.io&scope=repository:{image[0]}:pull").read().decode()
        
        token=json.loads(token)["token"]

    #Get right architecture
    if registry=='docker':
        manifest_list=urllib.request.Request(f"https://index.docker.io/v2/{image[0]}/manifests/{image[1]}", headers={'Authorization':f"Bearer {token}","Accept":"application/vnd.docker.distribution.manifest.list.v2+json"})
    elif registry=='quay':
        manifest_list=urllib.request.Request(f"https://quay.io/v2/{image[0]}/manifests/{image[1]}", headers={"Accept":"application/vnd.docker.distribution.manifest.list.v2+json"})
    
    manifest_list=urllib.request.urlopen(manifest_list).read().decode()
    
    architecture=platform.machine()
    
    #Handle some Linux distros that report aarch64 instead of amr64
    if architecture=='aarch64':
        architecture=['arm64']
        
    #Handle the arm* family
    elif architecture.startswith('arm'):
        
        #Handle armv6, armv7l, etc.
        if 'v' in architecture:
            architecture=architecture.split('v')
            architecture[1]='v'+architecture[1]
        else:
            architecture=[architecture]
    else:
        architecture=[architecture]
        
    manifest_list=json.loads(manifest_list)['manifests']
    
    for manifest in manifest_list:
        if manifest['platform']['architecture']==architecture[0]:
            #Deal with armv* family
            if len(architecture)==2:
                if manifest['platform']['variant']==architecture[1]:
                    digest=manifest['digest']
                    break
            else:
                digest=manifest['digest']
                break

    #Get information about layers
    
    if registry=='docker':
        layers=urllib.request.Request(f"https://index.docker.io/v2/{image[0]}/manifests/{digest}", headers={'Authorization':f"Bearer {token}","Accept":"application/vnd.docker.distribution.manifest.v2+json"})
    elif registry=='quay':
        layers=urllib.request.Request(f"https://quay.io/v2/{image[0]}/manifests/{digest}", headers={"Accept":"application/vnd.docker.distribution.manifest.v2+json"})
    
    
    layers=urllib.request.urlopen(layers).read().decode()
    
    #config=json.loads(layers)['config']
    #config=urllib.request.Request(f"https://index.docker.io/v2/{image[0]}/manifests/{config['digest']}", headers={'Authorization':f"Bearer {token}","Accept":config['mediaType']})
    #config=urllib.request.urlopen(config).read().decode()
    
    layers=json.loads(layers)["layers"]
    
    layers=[_["digest"] for _ in layers]
    
    
    #Special code for urlretrieve
    if registry=='docker':
        opener = urllib.request.build_opener()
        opener.addheaders = [('Authorization', f"Bearer {token}")]
        urllib.request.install_opener(opener)
    
    #Initialize container
    Container(container,_flags=flags+['--no-edit']).Init()
    
    #Download layers
    for i in range(len(layers)):
        if registry=='docker':
            urllib.request.urlretrieve(f"https://index.docker.io/v2/{image[0]}/blobs/{layers[i]}", f"{temp_folder}/layer_{i}.tar.gz")
        elif registry=='quay':
            urllib.request.urlretrieve(f"https://quay.io/v2/{image[0]}/blobs/{layers[i]}", f"{temp_folder}/layer_{i}.tar.gz")
        
        #Extract layer to container and remove it
        Shell(["tar","-xf",f"{temp_folder}/layer_{i}.tar.gz","-C",f"{ROOT}/{container}/diff"])
        os.remove(f"{temp_folder}/layer_{i}.tar.gz")
    
    shutil.rmtree(temp_folder)

#Convert Dockerfile to Containerfile
def Convert():
    IN=NAME[0]
    OUT=NAME[1]
    
    #Convert a line of a Dockerfile into a Container file
    def docker_to_container(line):
        COMMAND=line.split(' ')[0]
        line=line.split(' ')[1:]
        #Remove flags from line
        for i in range(len(line)):
            if not line[i].startswith("--"):
                line=line[i:]
                break
        
        line=list(filter(None,line))
        result=[]
        if COMMAND=='FROM':
            result=["Base",f"{split_by_char(line[0])[0]}"]
        elif COMMAND=='RUN':
            result=["Run",f"{' '.join(line)}"]
        elif COMMAND=='WORKDIR':
            result=["Workdir",f"{line[0]}"]
        elif COMMAND=='COPY':
            result=["Copy",f"{line[0]}",f"{line[1]}"]
        elif COMMAND=='ENV':
            result=["Env",f"{' '.join(line)}"]
        else:
            result=['','']
        
        #Escape all strings because of Python syntax
        if ''.join(result):
            result=['"'+result[_].replace("'", r'\'').replace('"', r'\"')+'"' if _!=0 else result[_] for _ in range(len(result))]
        
        return result[0]+f"({', '.join(result[1:])})"
        
    #Move all bash line breaks to one line
    with open(IN,'r') as f:
        Dockerfile=f.read().replace("\\\n"," ")
    
    with open(OUT,'w') as f:    
        for line in Dockerfile.splitlines():
            line=line.strip()
            if not line.startswith('#') and line:
                result=docker_to_container(line)
                if result!="()":
                    f.write(result+"\n")

#If FUNCTION is one of the "special functions", do that function
if FUNCTION in ['import','convert']:
    globals()[FUNCTION.title()]()
    exit()

#Else, it's one of the standard functions:
NAMES=List(NAMES)

if NAMES==[]:
    print("No containers specified!")
    exit()

for name in NAMES:
    
    BASE="void"
    UNIONOPTS="diff=RW"
    
    try:
        container=Container(name,FLAGS,UNIONOPTS)
    except ContainerDoesNotExist:
        print(f"Container {name} does not exist")
        continue
    
    #Export all container methods to be used in container-compose.py and Containerfile
    for func in [func for func in dir(Container) if callable(getattr(Container, func)) and not func.startswith('__')]:
        exec(f"{func} = container.{func}")
   
    if not callable(getattr(container, FUNCTION.title(),None)):
        print(f"Command {FUNCTION} doesn't exist!")
        exit()
    else:
        result=list(flatten([getattr(container,FUNCTION.title())()]))
    print_result(result)
        

    
